# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, Jackie PENG
# This file is distributed under the same license as the qteasy package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: qteasy 1.4\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-03-02 22:00+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../tutorials/1-get-started.md:1
msgid "安装方法及初始配置"
msgstr ""

#: ../../tutorials/1-get-started.md:3
#: ../../tutorials/2-get-data.md:3
#: ../../tutorials/3-start-first-strategy.md:3
#: ../../tutorials/4-build-in-strategies.md:3
#: ../../tutorials/5-first-self-defined-strategy.md:3
#: ../../tutorials/6-more-self-defined-strategies.md:4
msgid "`qteasy`是一个完全本地化部署和运行的量化交易分析工具包，具备以下功能："
msgstr ""

#: ../../tutorials/1-get-started.md:5
#: ../../tutorials/2-get-data.md:5
#: ../../tutorials/3-start-first-strategy.md:5
#: ../../tutorials/4-build-in-strategies.md:5
#: ../../tutorials/5-first-self-defined-strategy.md:5
#: ../../tutorials/6-more-self-defined-strategies.md:6
#: ../../tutorials/7-more-complicated-self-define-srtategy.md:12
msgid "金融数据的获取、清洗、存储以及处理、可视化、使用"
msgstr ""

#: ../../tutorials/1-get-started.md:6
#: ../../tutorials/2-get-data.md:6
#: ../../tutorials/3-start-first-strategy.md:6
#: ../../tutorials/4-build-in-strategies.md:6
#: ../../tutorials/5-first-self-defined-strategy.md:6
#: ../../tutorials/6-more-self-defined-strategies.md:7
#: ../../tutorials/7-more-complicated-self-define-srtategy.md:13
msgid "量化交易策略的创建，并提供大量内置基本交易策略"
msgstr ""

#: ../../tutorials/1-get-started.md:7
#: ../../tutorials/2-get-data.md:7
#: ../../tutorials/3-start-first-strategy.md:7
#: ../../tutorials/4-build-in-strategies.md:7
#: ../../tutorials/5-first-self-defined-strategy.md:7
#: ../../tutorials/6-more-self-defined-strategies.md:8
#: ../../tutorials/7-more-complicated-self-define-srtategy.md:14
msgid "向量化的高速交易策略回测及交易结果评价"
msgstr ""

#: ../../tutorials/1-get-started.md:8
#: ../../tutorials/2-get-data.md:8
#: ../../tutorials/3-start-first-strategy.md:8
#: ../../tutorials/4-build-in-strategies.md:8
#: ../../tutorials/5-first-self-defined-strategy.md:8
#: ../../tutorials/6-more-self-defined-strategies.md:9
#: ../../tutorials/7-more-complicated-self-define-srtategy.md:15
msgid "交易策略参数的优化以及评价"
msgstr ""

#: ../../tutorials/1-get-started.md:9
#: ../../tutorials/2-get-data.md:9
#: ../../tutorials/3-start-first-strategy.md:9
#: ../../tutorials/4-build-in-strategies.md:9
#: ../../tutorials/5-first-self-defined-strategy.md:9
#: ../../tutorials/6-more-self-defined-strategies.md:10
#: ../../tutorials/7-more-complicated-self-define-srtategy.md:16
msgid "交易策略的部署、实盘运行"
msgstr ""

#: ../../tutorials/1-get-started.md:11
msgid "`qteasy`使用`python`创建，使用向量化回测及交易模拟引擎实现了策略的高速回测，同时又兼顾策略框架的灵活性，使得用户可以根据需要灵活定制各种高级策。`qteasy`提供了多种策略参数优化算法，帮助优化及评价交易策略，同时提供了实时运行模式，使交易策略可以直接部署使用。"
msgstr ""

#: ../../tutorials/1-get-started.md:13
#: ../../tutorials/2-get-data.md:11
#: ../../tutorials/3-start-first-strategy.md:11
#: ../../tutorials/4-build-in-strategies.md:11
#: ../../tutorials/5-first-self-defined-strategy.md:11
#: ../../tutorials/6-more-self-defined-strategies.md:12
#: ../../tutorials/7-more-complicated-self-define-srtategy.md:18
msgid "通过本系列教程，您将会通过一系列的实际示例，充分了解`qteasy`的主要功能以及使用方法。"
msgstr ""

#: ../../tutorials/1-get-started.md:15
msgid "`qteasy`安装前的准备工作"
msgstr ""

#: ../../tutorials/1-get-started.md:17
msgid "创建安装环境"
msgstr ""

#: ../../tutorials/1-get-started.md:19
msgid "`qteasy`可以通过`pip`来安装，由于依赖包较多，为了避免各依赖包与现有环境中的包产生冲突，建议创建一个独立的`python`环境来安装`qteasy`。"
msgstr ""

#: ../../tutorials/1-get-started.md:21
msgid "创建虚拟环境的方法有很多种，这里介绍两种方法，分别是使用`venv`和`conda`："
msgstr ""

#: ../../tutorials/1-get-started.md:23
msgid "要使用`venv`创建虚拟环境，macOS和Linux用户可以打开终端，进入您需要创建环境的路径，输入以下命令，在当前目录下创建一个名为`qteasy-env`的虚拟环境，并激活环境："
msgstr ""

#: ../../tutorials/1-get-started.md:30
msgid "Windows用户可以打开命令提示符，进入您需要创建环境的文件夹，输入以下命令，创建虚拟环境并激活："
msgstr ""

#: ../../tutorials/1-get-started.md:37
msgid "要使用conda创建虚拟环境，可以打开终端，输入以下命令，创建一个名为`qteasy-env`的虚拟环境，并激活环境："
msgstr ""

#: ../../tutorials/1-get-started.md:44
msgid "在激活的虚拟环境中，使用以下命令安装`qteasy`："
msgstr ""

#: ../../tutorials/1-get-started.md:49
msgid "安装`MySQL`数据库 (可选)"
msgstr ""

#: ../../tutorials/1-get-started.md:51
msgid "`qteasy`可以管理大量的金融数据。`qteasy`的工作方式是将所有的金融数据下载到本地，清洗后存储到事先定义好的数据表中，在需要时（生成K线图、交易信号生成、模拟交易回测、交易结果评价等所有环节都需要用到金融数据）从本地数据源直接读取所需的数据。因此，必须在本地设置一个数据管理环境。"
msgstr ""

#: ../../tutorials/1-get-started.md:53
msgid "`qteasy`同时支持数据库及文件系统作为数据管理环境，考虑到金融数据量，强烈推荐使用数据库作为本地数据源。`qteasy`支持的本地数据源包括："
msgstr ""

#: ../../tutorials/1-get-started.md:55
msgid "**`csv` 文件** 默认数据源。占用空间大，但是可以使用Excel读取本地数据，数据量大时速度慢"
msgstr ""

#: ../../tutorials/1-get-started.md:56
msgid "**`mysql` 数据库**，强烈推荐使用mysql数据库并确保磁盘有至少1TB的存储空间，速度快"
msgstr ""

#: ../../tutorials/1-get-started.md:57
msgid "**`hdf5` 文件** 占用空间大，数据量大时速度慢"
msgstr ""

#: ../../tutorials/1-get-started.md:58
msgid "**`feather` 文件** 占用空间较小，数据量大时速度慢"
msgstr ""

#: ../../tutorials/1-get-started.md:60
msgid "为了实现最佳的数据存储效率，建议使用`mysql`数据库作为本地数据源。"
msgstr ""

#: ../../tutorials/1-get-started.md:62
msgid "如果需要使用数据库作为本地数据源，参照以下方法安装`MySQL`数据库，如果使用文件作为本地数据源，可以跳过这一步。"
msgstr ""

#: ../../tutorials/1-get-started.md:64
msgid "在`MySQL`的[官网](https://dev.mysql.com/downloads/mysql/)可以直接找到社区开源版本下载: 网站提供了dmg和tar等多种不同的安装方式，而且还有针对Apple M1芯片的版本可选："
msgstr ""

#: ../../tutorials/1-get-started.md:67
msgid "![png](img/mysql.png)"
msgstr ""

#: ../../tutorials/1-get-started.md:67
#: ../../tutorials/1-get-started.md:103
#: ../../tutorials/1-get-started.md:107
#: ../../tutorials/1-get-started.md:111
#: ../../tutorials/2-get-data.md:274
#: ../../tutorials/2-get-data.md:277
#: ../../tutorials/2-get-data.md:280
#: ../../tutorials/2-get-data.md:283
#: ../../tutorials/2-get-data.md:286
#: ../../tutorials/2-get-data.md:289
#: ../../tutorials/2-get-data.md:292
#: ../../tutorials/2-get-data.md:295
#: ../../tutorials/2-get-data.md:298
#: ../../tutorials/2-get-data.md:301
#: ../../tutorials/2-get-data.md:304
#: ../../tutorials/4-build-in-strategies.md:359
#: ../../tutorials/4-build-in-strategies.md:430
#: ../../tutorials/4-build-in-strategies.md:490
#: ../../tutorials/7-more-complicated-self-define-srtategy.md:244
msgid "png"
msgstr ""

#: ../../tutorials/1-get-started.md:69
msgid "安装完成后，创建用户，设置访问方式并设置密码："
msgstr ""

#: ../../tutorials/1-get-started.md:88
msgid "数据库设置好之后，`qteasy`会自动创建数据库表，将金融数据存储到数据库中。"
msgstr ""

#: ../../tutorials/1-get-started.md:90
msgid "安装`pymysql`"
msgstr ""

#: ../../tutorials/1-get-started.md:96
msgid "创建`tushare`账号并获取API token (可选)"
msgstr ""

#: ../../tutorials/1-get-started.md:98
msgid "`qteasy`可以从多个不同的网络金融数据提供商获取金融数据，将他们清洗、整理、一致化以后保存在本地数据库中。"
msgstr ""

#: ../../tutorials/1-get-started.md:100
msgid "尽管qteasy在不断地增加金融数据获取渠道，不过目前仍然主要依赖`tushare`。系统内建了比较完整的`tushare`接口API。鉴于`tushare`的接口均有权限或积分要求，建议用户提前准备好相应的`tushare`积分，并开通相应权限。"
msgstr ""

#: ../../tutorials/1-get-started.md:103
msgid "![png](img/tushare-3.png)"
msgstr ""

#: ../../tutorials/1-get-started.md:105
msgid "注册tushare账号和权限的方法请参见[tushare pro主页](https://tushare.pro):"
msgstr ""

#: ../../tutorials/1-get-started.md:107
msgid "![png](img/tushare.png)"
msgstr ""

#: ../../tutorials/1-get-started.md:109
msgid "如果不创建`tushare`账号，`qteasy`仍然可以获得一些数据，但是数据的种类非常有限，访问频率和次数也受到限制，很多`qteasy`功能的使用将会受到限制，如下图所示:"
msgstr ""

#: ../../tutorials/1-get-started.md:111
msgid "![png](img/tushare4.png)"
msgstr ""

#: ../../tutorials/1-get-started.md:113
msgid "目前已经有部分高频金融数据可以通过`akshare`或者东方财富网免费获取，未来的版本更新中会进一步增加通过其他网络渠道获取的数据。"
msgstr ""

#: ../../tutorials/1-get-started.md:115
msgid "安装TA-lib (可选)"
msgstr ""

#: ../../tutorials/1-get-started.md:117
msgid "`qteasy`内置了大量的技术指标，这些技术指标的计算依赖于`TA-lib`，如果需要使用`qteasy`内置的所有技术指标，需要安装`TA-lib`。 如果跳过这一步，将只能使用以下内置策略，这里有[完整的内置策略清单及详细说明参考文档](https://qteasy.readthedocs.io/zh/latest/api/Built_In.html)以及[内置交易策略回测结果](https://qteasy.readthedocs.io/zh/latest/references/1-build-in-results.html):"
msgstr ""

#: ../../tutorials/1-get-started.md:0
#: ../../tutorials/4-build-in-strategies.md:0
msgid "ID"
msgstr ""

#: ../../tutorials/1-get-started.md:0
#: ../../tutorials/4-build-in-strategies.md:0
msgid "策略名称"
msgstr ""

#: ../../tutorials/1-get-started.md:0
#: ../../tutorials/4-build-in-strategies.md:0
msgid "说明"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "crossline"
msgstr ""

#: ../../tutorials/1-get-started.md:0
#: ../../tutorials/4-build-in-strategies.md:0
msgid "`TimingCrossline`"
msgstr ""

#: ../../tutorials/1-get-started.md:0
#: ../../tutorials/4-build-in-strategies.md:0
msgid "crossline择时策略类，利用长短均线的交叉确定多空状态<br />1，当短均线位于长均线上方，且距离大于l\\*m%时，设置仓位目标为1<br />2，当短均线位于长均线下方，且距离大于l\\*m%时，设置仓位目标为-1<br />3，当长短均线之间的距离不大于l\\*m%时，设置仓位目标为0"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "macd"
msgstr ""

#: ../../tutorials/1-get-started.md:0
#: ../../tutorials/4-build-in-strategies.md:0
msgid "`TimingMACD`"
msgstr ""

#: ../../tutorials/1-get-started.md:0
#: ../../tutorials/4-build-in-strategies.md:0
msgid "MACD择时策略类，运用MACD均线策略，生成目标仓位百分比:<br />1，当MACD值大于0时，设置仓位目标为1<br />2，当MACD值小于0时，设置仓位目标为0"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "dma"
msgstr ""

#: ../../tutorials/1-get-started.md:0
#: ../../tutorials/4-build-in-strategies.md:0
msgid "`TimingDMA`"
msgstr ""

#: ../../tutorials/1-get-started.md:0
#: ../../tutorials/4-build-in-strategies.md:0
msgid "DMA择时策略<br />1， DMA在AMA上方时，多头区间，即DMA线自下而上穿越AMA线后，输出为1<br />2， DMA在AMA下方时，空头区间，即DMA线自上而下穿越AMA线后，输出为0"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "trix"
msgstr ""

#: ../../tutorials/1-get-started.md:0
#: ../../tutorials/4-build-in-strategies.md:0
msgid "`TimingTRIX`"
msgstr ""

#: ../../tutorials/1-get-started.md:0
#: ../../tutorials/4-build-in-strategies.md:0
msgid "TRIX择时策略，使用股票价格的三重平滑指数移动平均价格进行多空判断:<br />计算价格的三重平滑指数移动平均价TRIX，再计算M日TRIX的移动平均：<br />1， TRIX位于MATRIX上方时，设置仓位目标为1<br />2， TRIX位于MATRIX下方时，设置仓位目标位-1"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "ssma"
msgstr ""

#: ../../tutorials/1-get-started.md:0
#: ../../tutorials/4-build-in-strategies.md:0
msgid "`SCRSSMA`"
msgstr ""

#: ../../tutorials/1-get-started.md:0
#: ../../tutorials/4-build-in-strategies.md:0
msgid "单均线交叉策略——SMA均线(简单移动平均线)：根据股价与SMA均线的相对位置设定持仓比例"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "sema"
msgstr ""

#: ../../tutorials/1-get-started.md:0
#: ../../tutorials/4-build-in-strategies.md:0
msgid "`SCRSEMA`"
msgstr ""

#: ../../tutorials/1-get-started.md:0
#: ../../tutorials/4-build-in-strategies.md:0
msgid "单均线交叉策略——EMA均线(指数平滑移动均线)：根据股价与EMA均线的相对位置设定持仓比例"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "dsma"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "`DCRSSMA`"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "双均线交叉策略——SMA均线(简单移动平均线)：<br />基于SMA均线计算规则生成快慢两根均线，根据快与慢两根均线的相对位置设定持仓比例"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "dema"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "`DCRSEMA`"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "双均线交叉策略——SMA均线(简单移动平均线)：<br />基于EMA均线计算规则生成快慢两根均线，根据快与慢两根均线的相对位置设定持仓比例"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "slema"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "`SLPEMA`"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "均线斜率交易策略——EMA均线(指数平滑移动平均线)：<br />基于EMA计算规则生成移动均线，根据均线的斜率设定持仓比例目标"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "signal_none"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "`SignalNone`"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "空交易信号策略：不生成任何交易信号的策略"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "sellrate"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "`SellRate`"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "变化率卖出信号策略：当价格的变化率超过阈值时，产生卖出信号<br />1，当change > 0，且day日涨幅大于change时，产生-1卖出信号<br />2，当change < 0，且day日跌幅大于change时，产生-1卖出信号"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "buyrate"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "`BuyRate`"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "变化率买入信号策略：当价格的变化率超过阈值时，产生买入信号<br />1，当change > 0，且day日涨幅大于change时，产生1买入信号<br />2，当change < 0，且day日跌幅大于change时，产生1买入信号"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "long"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "`TimingLong`"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "简单择时策略，整个历史周期上固定保持多头全仓状态"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "short"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "`TimingShort`"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "简单择时策略，整个历史周期上固定保持空头全仓状态"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "zero"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "`TimingZero`"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "简单择时策略，整个历史周期上固定保持空仓状态"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "all"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "`SelectingAll`"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "保持历史股票池中的所有股票都被选中，投资比例平均分配"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "select_none"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "`SelectingNone`"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "保持历史股票池中的所有股票都不被选中，投资仓位为0"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "random"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "`SelectingRandom`"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "在每个历史分段中，按照指定的比例（p<1时）随机抽取若干股票，或随机抽取指定数量（p>=1）的股票进入投资组合，投资比例平均分配"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "finance"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "`SelectingAvgIndicator`"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "以股票过去一段时间内的财务指标的平均值作为选股因子选股，基础选股策略：以股票的历史指标的平均值作为选股因子，因子排序参数可以作为策略参数传入，改变策略数据类型，根据不同的历史数据选股，选股参数可以通过pars传入"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "ndaylast"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "`SelectingNDayLast`"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "以股票N天前的价格或数据指标作为选股因子选股"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "ndayavg"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "`SelectingNDayAvg`"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "以股票过去N天的价格或数据指标的平均值作为选股因子选股"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "ndayrate"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "`SelectingNDayRateChange`"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "以股票过去N天的价格或数据指标的变动比例作为选股因子选股"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "ndaychg"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "`SelectingNDayChange`"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "以股票过去N天的价格或数据指标的变动值作为选股因子选股"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "ndayvol"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "`SelectingNDayVolatility`"
msgstr ""

#: ../../tutorials/1-get-started.md:0
msgid "根据股票以前N天的股价波动率作为选股因子"
msgstr ""

#: ../../tutorials/1-get-started.md:148
msgid "下面简单介绍`TA-lib`的安装方法："
msgstr ""

#: ../../tutorials/1-get-started.md:150
msgid "完整的`TA-Lib`包无法通过pip安装，因为通过`pip install ta-lib`安装的只是TA-Lib包的一个`python wrapper`, 用户必须首先安装C语言的TA-Lib才能在python中使用它。"
msgstr ""

#: ../../tutorials/1-get-started.md:152
msgid "有些用户可以用下面的方法安装C语言的TA-Lib包： `conda install -c conda-forge libta-lib`"
msgstr ""

#: ../../tutorials/1-get-started.md:155
msgid "在不同的系统下安装C语言的TA-Lib包的方法："
msgstr ""

#: ../../tutorials/1-get-started.md:157
msgid "Windows"
msgstr ""

#: ../../tutorials/1-get-started.md:159
msgid "下载 [ta-lib-0.4.0-msvc.zip](http://prdownloads.sourceforge.net/ta-lib/ta-lib-0.4.0-msvc.zip) 并解压至 `C:\\ta-lib`."
msgstr ""

#: ../../tutorials/1-get-started.md:160
msgid "下载并安装 `Visual Studio Community` (2015 或更新版本)， 选择 `[Visual C++]` 功能"
msgstr ""

#: ../../tutorials/1-get-started.md:161
msgid "Windows 开始菜单, 启动 `[VS2015 x64 Native Tools Command Prompt]`"
msgstr ""

#: ../../tutorials/1-get-started.md:162
msgid "移动至 `C:\\ta-lib\\c\\make\\cdr\\win32\\msvc`"
msgstr ""

#: ../../tutorials/1-get-started.md:163
msgid "`nmake`"
msgstr ""

#: ../../tutorials/1-get-started.md:165
msgid "Mac OS"
msgstr ""

#: ../../tutorials/1-get-started.md:171
msgid "如果使用Apple Silicon芯片，可以使用："
msgstr ""

#: ../../tutorials/1-get-started.md:177
msgid "Linux"
msgstr ""

#: ../../tutorials/1-get-started.md:179
msgid "下载 [ta-lib-0.4.0-src.tar.gz](http://prdownloads.sourceforge.net/ta-lib/ta-lib-0.4.0-src.tar.gz) ，然后:"
msgstr ""

#: ../../tutorials/1-get-started.md:188
msgid "安装完成C语言`TA-Lib`后，可以安装`TA-Lib`的`python wrapper`："
msgstr ""

#: ../../tutorials/1-get-started.md:194
msgid "更完整的`TA-Lib`的安装方法请参考[这里](https://pypi.org/prject/TA-Lib/)"
msgstr ""

#: ../../tutorials/1-get-started.md:197
msgid "初始化`QTEASY`"
msgstr ""

#: ../../tutorials/1-get-started.md:199
msgid "当`qteasy`的所有依赖包正确安装后，就可以在IDE中导入`qteasy`了。"
msgstr ""

#: ../../tutorials/1-get-started.md:206
msgid "第一次导入`qteasy`时会自动初始化，初始化过程会创建一个`qteasy.cfg`文件，这个文件用于存储qteasy的环境配置变量，用户可以通过修改这个文件来修改`qteasy`的环境配置变量。"
msgstr ""

#: ../../tutorials/1-get-started.md:208
msgid "用户可以将一些关键配置信息存放在`qteasy.cfg`文件中，这样`qteasy`在导入时会自动读取这些配置信息。"
msgstr ""

#: ../../tutorials/1-get-started.md:210
msgid "访问`QTEASY`初始配置文件的两种方法"
msgstr ""

#: ../../tutorials/1-get-started.md:212
msgid "为了方便用户编辑`qteasy`的初始配置文件，`qteasy`提供了两种方法："
msgstr ""

#: ../../tutorials/1-get-started.md:214
msgid "1，使用`qteasy.update_start_up_setting()`方法"
msgstr ""

#: ../../tutorials/1-get-started.md:216
msgid "`qteasy`提供了一系列的内置函数，方便用户在启动后显示和修改启动配置信息。"
msgstr ""

#: ../../tutorials/1-get-started.md:218
msgid "要查看当前的启动配置，使用函数`qteasy.start_up_settings()`打印当前的启动配置信息："
msgstr ""

#: ../../tutorials/1-get-started.md:227
msgid "第一次启动`qteasy`时启动配置文件为空，此时打印出的信息为空。"
msgstr ""

#: ../../tutorials/1-get-started.md:229
msgid "要修改或更新启动配置文件，直接调用函数`qteasy.update_start_up_setting(**kwargs)`,传入的参数将被写入启动配置文件："
msgstr ""

#: ../../tutorials/1-get-started.md:248
msgid "如果上述信息有错，可以随时修改，关闭IDE后重新`import qteasy`即可生效"
msgstr ""

#: ../../tutorials/1-get-started.md:250
msgid "2，直接访问`qteasy.cfg`文件"
msgstr ""

#: ../../tutorials/1-get-started.md:252
msgid "用户可以在资源管理器、访达或者终端中找到`qteasy`的根目录，然后打开`qteasy.cfg`文件，修改其中的内容。"
msgstr ""

#: ../../tutorials/1-get-started.md:253
msgid "在qteasy中可以通过`qt.QT_ROOT_PATH`查看qteasy的根目录"
msgstr ""

#: ../../tutorials/1-get-started.md:259
msgid "第一次初始化后的`qteasy.cfg`文件内容如下："
msgstr ""

#: ../../tutorials/1-get-started.md:268
msgid "用户可以直接在文件中添加配置信息，保存文件后重新导入`qteasy`即可使配置生效了，例如："
msgstr ""

#: ../../tutorials/1-get-started.md:274
msgid "以下几个配置信息是用户在使用`qteasy`前非常有必要配置的："
msgstr ""

#: ../../tutorials/1-get-started.md:276
msgid "配置`tushare`的API token"
msgstr ""

#: ../../tutorials/1-get-started.md:278
msgid "注意`tushare`是一个收费的数据服务，用户需要获取积分，积分越多，获取的数据种类越多，权限也越大，如果不配置`tushare token`，将无法正常使用`tushare`的数据服务。"
msgstr ""

#: ../../tutorials/1-get-started.md:280
msgid "如果您按照教程前一节的内容创建了`tushare`账号并获取了`token`，可以将token写入`qteasy.cfg`文件中，这样在导入`qteasy`时就会自动读取这个`token`。"
msgstr ""

#: ../../tutorials/1-get-started.md:282
msgid "在`qteasy.cfg`文件中添加以下内容："
msgstr ""

#: ../../tutorials/1-get-started.md:288
msgid "配置本地数据源"
msgstr ""

#: ../../tutorials/1-get-started.md:290
msgid "默认情况下，`qteasy`使用csv文件保存本地数据，速度较慢而且占用空间较大。为了更好地使用`qteasy`，用户还应该完成本地数据源的基本配置。"
msgstr ""

#: ../../tutorials/1-get-started.md:292
msgid "如果您按照教程前一节的内容创建了`mysql`数据库，可以将数据库的配置信息写入`qteasy.cfg`文件中，这样`qteasy`就会连接到您指定的数据库，将金融数据存储到数据库中。"
msgstr ""

#: ../../tutorials/1-get-started.md:294
msgid "在`qteasy.cfg`文件中添加以下内容，"
msgstr ""

#: ../../tutorials/1-get-started.md:305
msgid "或者使用`qteasy.update_start_up_setting()`："
msgstr ""

#: ../../tutorials/1-get-started.md:312
msgid "如果不做上述配置，`qteasy`会使用默认的csv文件作为本地数据源。"
msgstr ""

#: ../../tutorials/1-get-started.md:314
msgid "请注意，在文件中给出配置信息的时候，请不要加`<`和`>`，否则，这些字符也会被认为是`token`或者数据库名的一部份。从而导致连接数据库失败。"
msgstr ""

#: ../../tutorials/1-get-started.md:316
msgid "`qteasy`在解析配置文件的时候，会根据配置的类型，自动转换为正确的格式，例如，数据库端口`3306`应该是`int`变量，直接使用："
msgstr ""

#: ../../tutorials/1-get-started.md:322
msgid "即可。`qteasy`会将字符串`3306`转换为`int`型`3306`。·"
msgstr ""

#: ../../tutorials/1-get-started.md:324
msgid "下面这个配置文件的例子是正确的："
msgstr ""

#: ../../tutorials/1-get-started.md:338
msgid "开始下载第一批金融数据"
msgstr ""

#: ../../tutorials/1-get-started.md:340
msgid "完成上述配置以后，保存并关闭`qteasy.cfg`文件，恭喜你，`qteasy`已经安装并配置好了，现在可以开始使用`qteasy`了。"
msgstr ""

#: ../../tutorials/1-get-started.md:342
msgid "首先，我们需要下载一些金融数据，交易策略的回测、优化、评价等所有功能都需要用到金融数据。 在这里，我们可以先下载一些股票数据，以便后续的教程中使用。"
msgstr ""

#: ../../tutorials/1-get-started.md:345
msgid "`qt.refill_data_source`是一个通用的数据下载函数，通过指定数据表名称，数据获取渠道（默认`tushare`)，开始日期/结束日期和股票代码，`qteasy`就能连接上相应的网络数据提供商，自动分批下载数据。当下载数据量很大时，该函数会自动处理数据拆分。同时，该函数会自动处理网络延迟导致的数据下载失败问题，同时提供了限流选项，防止下载流量过大导致连接失败。下载完成的数据会自动进行清洗整理和去重，确保写入`DataSource`中的数据是干净的。关于`refill_data_source()`函数的更多介绍，请参见[api_reference](../api/api_reference.rst)。"
msgstr ""

#: ../../tutorials/1-get-started.md:347
msgid "通过`refill_data_source`函数，您可以下载股票、期货、指数、基金等金融数据，也可以下载宏观经济、财务报表、财务指标、公司基本信息等非交易数据。`qteasy`可以批量下载数据到本地，另外，还可以使用多线程并行下载，提供下载进度条，特别适合一次性下载大量历史数据保存到本地，也适合定期运行，定期补充增量数据，例如每月或每周补充下载本月或本周的所有数据。"
msgstr ""

#: ../../tutorials/1-get-started.md:349
msgid "目前支持从`tushare` / `akshare` / `eastmoney` 等渠道获取数据，不过暂时以`tushare`为主，`tushare`渠道涵盖了所有的数据API，其他两种渠道的API会随版本更新逐步添加。"
msgstr ""

#: ../../tutorials/1-get-started.md:364
msgid "在`qteasy`中，所有数据都保存在特定的数据表中，而且每一种数据都有数据ID，例如`pe`表示市盈率，`open`表示开盘价，等等；通过数据ID，用户可以在`qteasy`中随时获取所需的数据——只要数据已经下载到本地。"
msgstr ""

#: ../../tutorials/1-get-started.md:366
msgid "同时，数据ID也是`qteasy`中交易策略的核心，用户可以通过数据ID在交易策略中\"订阅\"所需要的数据类型，并根据这些数据生成交易信号（关于交易信号和交易策略，请参见教程第四章）。"
msgstr ""

#: ../../tutorials/1-get-started.md:368
msgid "根据您的网络环境和数据量大小，下载数据的时间可能会有所不同，下载完成后，2023年内的所有股票数据就可以直接获取了。"
msgstr ""

#: ../../tutorials/1-get-started.md:370
msgid "要获取历史数据，可以使用`get_history_data`函数，在参数中指定数据类型、股票代码、开始日期和结束日期， 下面的代码可以获取2023年1月1日到3月1日的股票000001.SZ的开盘价、最高价、最低价、收盘价、成交量、成交额等数据："
msgstr ""

#: ../../tutorials/1-get-started.md:387
msgid "至此，如果您看到上面的数据，表明`qteasy`的安装和初始化工作已经完成，您已经可以开始使用`qteasy`了。"
msgstr ""

#: ../../tutorials/1-get-started.md:389
msgid "在下一章节中，我们将会介绍`qteasy`的基本数据类型，以及如何使用`qteasy`来获取并管理金融数据。"
msgstr ""

#: ../../tutorials/1-get-started.md:391
msgid "API 参考"
msgstr ""

#: ../../tutorials/1-get-started.md:393
msgid "关于qteasy环境变量的AP，以及所有的环境变量，请参考 [Configuration APIs](../api/api_reference.rst)"
msgstr ""

#: ../../tutorials/2-get-data.md:1
msgid "获取并管理金融数据"
msgstr ""

#: ../../tutorials/2-get-data.md:13
#: ../../tutorials/3-start-first-strategy.md:13
#: ../../tutorials/4-build-in-strategies.md:13
#: ../../tutorials/5-first-self-defined-strategy.md:13
#: ../../tutorials/6-more-self-defined-strategies.md:14
#: ../../tutorials/7-more-complicated-self-define-srtategy.md:20
msgid "开始前的准备工作"
msgstr ""

#: ../../tutorials/2-get-data.md:15
msgid "在开始本教程前，请完成以下工作："
msgstr ""

#: ../../tutorials/2-get-data.md:17
msgid "完成`qteasy`的安装并升级到最新版本"
msgstr ""

#: ../../tutorials/2-get-data.md:18
msgid "注册`tushare pro`账户并确保有一定的积分（大多数高级数据需要较多积分才能下载）"
msgstr ""

#: ../../tutorials/2-get-data.md:19
msgid "完成`qteasy.cfg`文件的配置，将`tushare_token`写入配置文件"
msgstr ""

#: ../../tutorials/2-get-data.md:20
msgid "完成`mysql`数据库的配置，并将数据库配置写入`qteasy.cfg·`(***可选项***)"
msgstr ""

#: ../../tutorials/2-get-data.md:21
msgid "完成`ta-lib`的安装 (***可选项***)"
msgstr ""

#: ../../tutorials/2-get-data.md:23
msgid "在[上一篇教程](1-get-started.md)中，我介绍了如何新建一个虚拟环境，并在新的虚拟环境中安装并初始化`qteasy`，如果还没有完成这一步的朋友，请移步前一篇教程完成`qteasy`的安装和基础配置。"
msgstr ""

#: ../../tutorials/2-get-data.md:25
msgid "另外，为了方便后续图表等功能的使用，建议使用`jupyter notebook`来进行开发，您可以在新建的虚拟环境中运行以下命令安装`jupyter notebook`："
msgstr ""

#: ../../tutorials/2-get-data.md:30
msgid "安装完成后，可以使用下面命令启动`jupyter notebook`："
msgstr ""

#: ../../tutorials/2-get-data.md:36
msgid "启动后，就可以在浏览器中的一个交互式开发环境中运行代码了，如下图所示："
msgstr ""

#: ../../tutorials/2-get-data.md:38
msgid "![在这里插入图片描述](img/jupyter_notebook.png)"
msgstr ""

#: ../../tutorials/2-get-data.md:38
#: ../../tutorials/2-get-data.md:156
#: ../../tutorials/2-get-data.md:243
#: ../../tutorials/2-get-data.md:252
#: ../../tutorials/3-start-first-strategy.md:164
#: ../../tutorials/3-start-first-strategy.md:166
#: ../../tutorials/3-start-first-strategy.md:257
#: ../../tutorials/3-start-first-strategy.md:276
#: ../../tutorials/3-start-first-strategy.md:360
#: ../../tutorials/5-first-self-defined-strategy.md:38
#: ../../tutorials/5-first-self-defined-strategy.md:67
#: ../../tutorials/5-first-self-defined-strategy.md:92
#: ../../tutorials/5-first-self-defined-strategy.md:125
#: ../../tutorials/5-first-self-defined-strategy.md:165
#: ../../tutorials/5-first-self-defined-strategy.md:311
#: ../../tutorials/5-first-self-defined-strategy.md:330
#: ../../tutorials/6-more-self-defined-strategies.md:289
#: ../../tutorials/6-more-self-defined-strategies.md:440
msgid "在这里插入图片描述"
msgstr ""

#: ../../tutorials/2-get-data.md:40
msgid "如果不使用`jupyter notebook`，也可以使用`ipython`："
msgstr ""

#: ../../tutorials/2-get-data.md:44
msgid "`ipython` 运行在terminal中，但是对图表的支持没有那么好"
msgstr ""

#: ../../tutorials/2-get-data.md:47
msgid "获取基础数据以及价格数据"
msgstr ""

#: ../../tutorials/2-get-data.md:49
msgid "如上一篇教程介绍，刚刚初始化的`qteasy`是无法调用任何历史数据的，所有历史数据都必须首先下载到本地，保存到一个称为`Datasource`的数据仓库之后，才能完成后续所有需要数据的工作，例如调用历史数据，进行策略的回测和优化等等。"
msgstr ""

#: ../../tutorials/2-get-data.md:51
msgid "`qteasy`需要使用的数据种类很多，所有的数据都是保存在一些预定义的数据表中，`Datasource`就是一系列数据表的集合。其中最基础的数据表包括："
msgstr ""

#: ../../tutorials/2-get-data.md:53
msgid "`trade_calendar` - 交易日历数据，包括不同交易所的开市、闭市日期计划，每年底更新下一年的交易日历"
msgstr ""

#: ../../tutorials/2-get-data.md:54
msgid "`stock_basics` - 股票基础信息，包括沪深股市所有股票的基本信息，包括代码、名称、全称、上市日期、分类等等基础信息"
msgstr ""

#: ../../tutorials/2-get-data.md:55
msgid "`index_basics` - 指数基础信息，包括沪深股市所有指数的基本信息，包括代码、名称、全称等等信息"
msgstr ""

#: ../../tutorials/2-get-data.md:57
msgid "在配置好`tushare_token`以后，第一次导入`qteasy`时，如果系统未找到交易日历数据，会显示信息提示交易日历无法读取。"
msgstr ""

#: ../../tutorials/2-get-data.md:59
msgid "关于`DataSource`数据源对象的更多信息，请参见[DataSource Reference]()"
msgstr ""

#: ../../tutorials/2-get-data.md:64
msgid "提示信息："
msgstr ""

#: ../../tutorials/2-get-data.md:70
msgid "`qteasy`提供了一个函数`get_table_overview()`来显示本地存储的数据信息，运行这个函数，可以打印出本地保存的数据表的清单，存储的数据量、占用的磁盘空间大小、以及数据范围等等。"
msgstr ""

#: ../../tutorials/2-get-data.md:76
msgid "数据表分析过程可能会花费几分钟时间，其间会显示进度条显示分析进度。分析完成以后，会显示本地数据源的数据表清单，以及数据表的数据范围等信息。"
msgstr ""

#: ../../tutorials/2-get-data.md:78
msgid "如果当前数据源中没有任何数据，会显示如下信息："
msgstr ""

#: ../../tutorials/2-get-data.md:90
msgid "如果本地数据源中没有数据，将会显示上面的内容。此时需要下载数据到本地数据源。"
msgstr ""

#: ../../tutorials/2-get-data.md:91
msgid "下载交易日历和基础数据"
msgstr ""

#: ../../tutorials/2-get-data.md:93
msgid "我们可以调用`refill_data_source`函数下载交易日历和基础数据。这个函数是`qteasy`的标准数据下载接口函数，所有的历史数据类型均可以通过此接口下载。这个函数的基本参数是`tables`，传入数据表的名称即可下载相应的数据到本地存储了。使用`refill_data_source`下载交易数据时，`qteasy`会自动进行数据清洗，排除重复数据，去除错误数据，发生错误自动重试，并将下载的数据合并到本地数据表中。目前`qteasy`仅支持通过`tushare`下载金融数据，未来还会增加其他的金融数据接口，丰富用户选择。"
msgstr ""

#: ../../tutorials/2-get-data.md:95
msgid "要下载前面提到的交易日历、股票和指数的基本信息，只需要运行下面的代码："
msgstr ""

#: ../../tutorials/2-get-data.md:100
msgid "数据下载过程中会显示进度条显示下载进度。"
msgstr ""

#: ../../tutorials/2-get-data.md:108
msgid "下载完成后，再次运行`qt.get_table_overview()`函数"
msgstr ""

#: ../../tutorials/2-get-data.md:113
msgid "可以看到数据已经成功下载到本地："
msgstr ""

#: ../../tutorials/2-get-data.md:126
msgid "可以看到，三张数据表已经被下载到本地数据源，数据源的类型为`\"file://csv@qt_root/data/\"`类型（即数据以`csv`文件形式存储在qt根路径的`/data/`路径下），包含三张数据表，其中交易日历的范围涵盖到2024年年底。"
msgstr ""

#: ../../tutorials/2-get-data.md:128
msgid "查看股票和指数的基础数据"
msgstr ""

#: ../../tutorials/2-get-data.md:130
msgid "上面的基础数据下载好之后，建议重新启动IDE，重新导入`qteasy`。这时，我们就可以使用`qteasy`筛选和查找股票/指数了。"
msgstr ""

#: ../../tutorials/2-get-data.md:132
msgid "查找股票/指数详细信息可以使用`get_stock_info()`或者`get_basic_info()`函数，两个函数功能相同，都可以根据输入的证券代码、名称或者关键字查找证券的信息，支持通配符或者模糊查找；如果同一个代码对应不同的`qt_code`，例如股票`000001`代表平安银行，对应`qt_code: 000001.SZ`，而指数`000001`代表上证指数，`qt_code: 000001.SZ`，`qteasy`会罗列出所有的证券信息："
msgstr ""

#: ../../tutorials/2-get-data.md:140
msgid "输出如下"
msgstr ""

#: ../../tutorials/2-get-data.md:154
msgid "更多的输出可以查看下图："
msgstr ""

#: ../../tutorials/2-get-data.md:156
msgid "![在这里插入图片描述](img/get_stock_info.png)"
msgstr ""

#: ../../tutorials/2-get-data.md:158
msgid "在上面的例子中，系统只找到了类型为股票和指数的证券，如果还需要查找基金、期货等更多的证券信息，用同样的方法下载更多的基础数据表即可："
msgstr ""

#: ../../tutorials/2-get-data.md:160
msgid "**fund_basic**: 基金基础数据"
msgstr ""

#: ../../tutorials/2-get-data.md:161
msgid "**future_basic**: 期货基础数据"
msgstr ""

#: ../../tutorials/2-get-data.md:163
msgid "除了查找股票或证券的基本信息以外，我们还能用`qt.filter_stock()`函数来筛选股票："
msgstr ""

#: ../../tutorials/2-get-data.md:167
msgid "输出："
msgstr ""

#: ../../tutorials/2-get-data.md:176
msgid "下载沪市股票数据"
msgstr ""

#: ../../tutorials/2-get-data.md:178
msgid "金融数据中最重要的数据类型非量价数据莫属。接下来，我们就来下载历史价格数据。"
msgstr ""

#: ../../tutorials/2-get-data.md:180
msgid "`qteasy`的历史数据全都是以K线数据的形式存储在数据表中的，目前支持的K线数据包括："
msgstr ""

#: ../../tutorials/2-get-data.md:182
msgid "分钟K线 - 1分钟/5分钟/15分钟/30分钟/60分钟K线"
msgstr ""

#: ../../tutorials/2-get-data.md:183
msgid "日K线"
msgstr ""

#: ../../tutorials/2-get-data.md:184
msgid "周K线"
msgstr ""

#: ../../tutorials/2-get-data.md:185
msgid "月K线"
msgstr ""

#: ../../tutorials/2-get-data.md:187
msgid "我们同样使用`qt.refill_data_source()`函数下载股票数据。最常用的股票日K线数据保存在`stock_daily`表中。不过由于数据量较大，我们最好在下载数据时限定数据的范围，通过`start_date`/`end_date`参数，指定下载数据的起始日期，分批下载历史数据，否则，下载的过程将会非常漫长："
msgstr ""

#: ../../tutorials/2-get-data.md:192
msgid "上面的代码下载了2023年全年所有已上市股票的日K线数据，同样，下面的代码可以用来下载常用指数（上证指数和沪深300指数）的日K线数据："
msgstr ""

#: ../../tutorials/2-get-data.md:197
msgid "从本地获取股价数据"
msgstr ""

#: ../../tutorials/2-get-data.md:198
msgid "当股价数据保存在本地之后，就可以随时提取出来使用了。"
msgstr ""

#: ../../tutorials/2-get-data.md:200
msgid "我们可以使用`qt.get_history_data()`函数来获取股票的量价数据。这个函数是`qteasy`的一个通用接口，可以用来获取各种类型的数据。在函数的参数中指定数据的类型（通过数据类型ID）、股票的代码以及其他参数，就可以获取相应的数据了。如果要获取刚刚下载的K线价格，需要设置数据类型为`\"open, high, low, close, vol\"`以获取开盘价、最高价、最低价、收盘价和交易量："
msgstr ""

#: ../../tutorials/2-get-data.md:206
msgid "得到结果如下："
msgstr ""

#: ../../tutorials/2-get-data.md:229
msgid "上面函数的输出是一个字典，字典的键为`shares`参数指定的所有股票的代码，而值为一个`DataFrame`，包含该股票在指定期间的历史数据，这里我们指定了数据类型为K线量价数据。当然，我们也可以指定其他的数据类型，只要这些数据已经下载到了本地，就可以直接读取。"
msgstr ""

#: ../../tutorials/2-get-data.md:231
msgid "例如，指定数据类型`htypes='pe, pb, total_mv'`可以获取股票的市盈率、市净率和总市值等三项财务指标。如果某些指标存在缺失值的时候，可以定义填充方式填充缺失值，还可以对数据进行重新采样，将每日的数据变为每周或每小时数据。"
msgstr ""

#: ../../tutorials/2-get-data.md:233
msgid "关于`get_history_data`函数参数的详细解释，请参见[qteasy文档](https://qteasy.readthedocs.io)"
msgstr ""

#: ../../tutorials/2-get-data.md:235
msgid "生成K线图"
msgstr ""

#: ../../tutorials/2-get-data.md:236
msgid "使用量价数据，更加方便易读的方法是将数据显示为K线图。"
msgstr ""

#: ../../tutorials/2-get-data.md:238
msgid "`qteasy`提供了`qt.candle()`函数，用于显示专业K线图，只要数据下载到本地后，就可以立即显示K线图："
msgstr ""

#: ../../tutorials/2-get-data.md:243
msgid "![在这里插入图片描述](img/candle-600004.png)"
msgstr ""

#: ../../tutorials/2-get-data.md:245
msgid "下载复权因子数据到本地后，就可以显示复权价格了："
msgstr ""

#: ../../tutorials/2-get-data.md:252
msgid "![在这里插入图片描述](img/candle-600004-b.png)"
msgstr ""

#: ../../tutorials/2-get-data.md:255
msgid "`qt.candle()`函数支持传入K线图的开始日期、结束日期、K线频率、复权方式以显示不同区间和频率的K线图，也支持传入移动均线的时长和macd的不同参数显示不同的均线，`qt.candle()`函数还支持通过股票名称显示K线图，如果输入是股票名称，会自动模糊查找，并且支持通配符。"
msgstr ""

#: ../../tutorials/2-get-data.md:257
msgid "下面是更多的K线图例子，展示了股票、基金、指数等不同的资产类别，不同的数据频率，不同的均线设定、不同的图表类型等，为了显示下面示例中的K线图，您需要下载相应的数据。"
msgstr ""

#: ../../tutorials/2-get-data.md:274
msgid "![png](img/output_18_1.png)"
msgstr ""

#: ../../tutorials/2-get-data.md:277
msgid "![png](img/output_18_2.png)"
msgstr ""

#: ../../tutorials/2-get-data.md:280
msgid "![png](img/output_18_3_copy.png)"
msgstr ""

#: ../../tutorials/2-get-data.md:283
msgid "![png](img/output_18_4.png)"
msgstr ""

#: ../../tutorials/2-get-data.md:286
msgid "![png](img/output_18_5.png)"
msgstr ""

#: ../../tutorials/2-get-data.md:289
msgid "![png](img/output_18_6.png)"
msgstr ""

#: ../../tutorials/2-get-data.md:292
msgid "![png](img/output_18_7.png)"
msgstr ""

#: ../../tutorials/2-get-data.md:295
msgid "![png](img/output_18_8.png)"
msgstr ""

#: ../../tutorials/2-get-data.md:298
msgid "![png](img/output_18_9.png)"
msgstr ""

#: ../../tutorials/2-get-data.md:301
msgid "![png](img/output_18_10.png)"
msgstr ""

#: ../../tutorials/2-get-data.md:304
msgid "![png](img/output_18_11.png)"
msgstr ""

#: ../../tutorials/2-get-data.md:306
msgid "数据类型的查找"
msgstr ""

#: ../../tutorials/2-get-data.md:307
msgid "前面提到过，`qteasy`中的所有数据类型均有一个唯一的ID，通过这个ID，可以提取数据，在交易策略中引用该数据类型，完成`qteasy`中所需的工作。"
msgstr ""

#: ../../tutorials/2-get-data.md:309
msgid "为了更加了解`qteasy`中的数据类型，我们可以用`qt.find_history_data()`函数来查询所需的数据类型。`qteasy`中定义的数据类型是与数据频率、资产类型挂钩的，也就是说，不同资产的收盘价是不同的数据类型，不同频率的收盘价也是不同的。"
msgstr ""

#: ../../tutorials/2-get-data.md:311
msgid "`qt.find_history_data()`函数可以根据输入查找相关的数据类型，并且显示它们的ID，数据表、说明等相关信息，例如，搜索`‘close’`（收盘价）可以找到所有相关的数据类型："
msgstr ""

#: ../../tutorials/2-get-data.md:316
#: ../../tutorials/2-get-data.md:365
msgid "得到下面输出："
msgstr ""

#: ../../tutorials/2-get-data.md:360
msgid "再例如，搜索市盈率pe，可以得到："
msgstr ""

#: ../../tutorials/2-get-data.md:378
msgid "查找到相应的数据之后，只需要查看该数据所属的数据表，将该数据表下载到本地数据源中(`refill_data_source(tables, ...)`)，即可使用这些数据(`qt.get_history_data(htype, shares, ...)`)了。"
msgstr ""

#: ../../tutorials/2-get-data.md:380
msgid "定期下载数据到本地"
msgstr ""

#: ../../tutorials/2-get-data.md:382
msgid "为了保持本地数据源的数据更新，我们可以使用`qt.refill_data_source()`函数定期下载数据到本地。创建一个文件`refill_data.py`，并在其中写入以下代码："
msgstr ""

#: ../../tutorials/2-get-data.md:428
msgid "上面的脚本文件提供了最基本的数据下载功能，可以根据需要修改`tables`和`start_date`、`end_date`参数，以及`parallel`和`merge_type`参数，来下载不同的数据类型和不同的数据范围。 您可以自行改进脚本文件以实现更多的功能"
msgstr ""

#: ../../tutorials/2-get-data.md:431
msgid "要下载2023年全年的`stock_daily`数据，只需要在命令行中运行以下命令："
msgstr ""

#: ../../tutorials/2-get-data.md:439
msgid "回顾总结"
msgstr ""

#: ../../tutorials/2-get-data.md:441
msgid "至此，我们已经初步了解了`qteasy`中对数据的管理方式，了解了数据下载的方法。下载了基本数据以及一些量价数据。我们学会了如何提取数据、如何显示K线图。最后，我们还学会了查询数据的方法，如果需要某种数据，知道如何查询，如何下载和调用这些数据。"
msgstr ""

#: ../../tutorials/2-get-data.md:443
msgid "在下一篇教程中，我们将进一步加深对`qteasy`的了解，我们将学会如何创建交易策略，如何运行并回测交易策略。"
msgstr ""

#: ../../tutorials/2-get-data.md:445
msgid "关于`qteasy`的更多介绍，请参见[qteasy文档](https://qteasy.readthedocs.io)"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:1
msgid "回测您的第一个交易策略"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:15
#: ../../tutorials/4-build-in-strategies.md:15
#: ../../tutorials/5-first-self-defined-strategy.md:15
#: ../../tutorials/6-more-self-defined-strategies.md:16
#: ../../tutorials/7-more-complicated-self-define-srtategy.md:22
msgid "在开始本节教程前，请先确保您已经掌握了下面的内容："
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:17
msgid "完成`qteasy`的安装并升级到最新版本，完成`qteasy`的初始化配置"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:18
msgid "配置好本地数据源，掌握下载各种金融数据的方法，能够将指数、股票的各种历史价格数据、财务报表数据等下载到本地。"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:20
msgid "在[上一篇教程](https://blog.csdn.net/Shepherdppz/article/details/136098697)中，我介绍了如何配置本地数据源，查找、下载金融数据到本地，并从本地数据源中提取数据。如果还没有完成这一步的朋友，请移步前一篇教程了解如何下载和操作数据。"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:22
#: ../../tutorials/4-build-in-strategies.md:23
#: ../../tutorials/5-first-self-defined-strategy.md:24
#: ../../tutorials/6-more-self-defined-strategies.md:26
#: ../../tutorials/7-more-complicated-self-define-srtategy.md:37
msgid "本节的目标"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:24
msgid "在本节中，我们将通过创建`qteasy`模块来测试一个大小盘轮动交易策略，"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:26
msgid "大小盘轮动是一个非常基本而且常见的交易策略，这个交易策略抓住大盘股和小盘股往往上涨和下跌不同步的特点，在大盘股和小盘股之间轮流切换持有，以期望获得更高的收益率。通过创建这个交易策略，可以非常方便地帮助我们了解如何使用`qteasy`创建交易策略，调用历史价格回测交易策略，分析策略的表现并对策略进行改进。"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:28
msgid "在这里，我们需要创建一个最简单的轮动策略：在前面提到的两个指数之间轮动，每天选择未来可能的涨幅较大的指数持有："
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:30
msgid "分别计算两个指数在过去20天的涨幅，也就是今天的价格相对于20天前价格的涨幅"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:31
msgid "选择涨幅较大的那个指数，在第二天持有，同时卖掉涨幅较小的指数"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:33
msgid "$$当日涨幅 = \\frac{Price_0}{Price_{20}} - 1$$"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:35
msgid "策略的实现"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:36
msgid "根据上述的策略思路，我们很容易在`qteasy`中实现这样的轮动选股策略，因为`qteasy`中已经内置了近70个交易策略，所有的内置策略都有独特的名称，直接引用名称即可使用这些内置策略。`qteasy`中的所有交易策略都必须包含在一个名为`Operator`（交易员）的对象中，交易员对象实际是一个策略的容器，可以理解为一个交易员可以同时管理多个策略，并且同时运行这些策略来生成交易信号。"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:38
msgid "交易员对象可以直接通过`qt.Operator()`来创建，创建时传递`strategies`参数即可在创建时同时创建交易策略："
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:43
msgid "通过上面的代码，我们已经在`queasy`中创建了一个选股策略（`ndayrate`），这个策略是一个内置选股策略，它根据“N日价格涨幅”来选股，它的选股逻辑是判断股票池中所有股票的N日价格涨幅，并且根据价格涨幅选择股票或资产（当然，选择的方法是通过参数配置的，在下文中会提到）。"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:45
msgid "使用`qt.built_ins()`函数，可以查看内置策略的详细介绍："
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:87
msgid "至此，一个`Operator`对象和交易策略就已经创建好了。"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:89
msgid "我们可以使用`Operator.info()`来查看交易员对象和交易策略的详细信息，同时，通过`Operator.strategies`属性可以访问其中的所有交易策略，通过它的`info()`方法也可以查看更详细的策略参数和信息"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:123
msgid "从上面的信息中可以看到，`ndayrate`策略有许多的可配置参数，通过调整这些参数，我们可以调整策略的选股方式，从而调整交易策略的表现。"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:125
msgid "接下来，我们还需要做一些最基本的设定，确保这个选股策略能按照我们的想法选股。`Operator`对象中的所有参数都可以通过`op.set_parameter()`方法来实现。"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:135
msgid "在上面的代码段中，我们通过几个简单的参数设置选股策略的基本行为："
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:137
msgid "`sample_freq='d'`: 每日选股，如果设置选股周期为`'w'`表示每周选股，`'2d'`表示每两天选股一次"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:138
msgid "`sort_ascending=False`：该策略的操作方式是将所有的N日涨幅排序后取前几位，因为需要取最大涨幅，因此需要降序排列，如果要取最小涨幅，则需要设置`sort_ascending=True`"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:139
msgid "`proportion_or_quantity=1`：选择的股票数量，因为从两个指数中固定二选一，因此设置此参数为1"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:140
msgid "`pars=(20, )`：策略参数N，设置为20表示根据20日涨幅选股"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:141
msgid "`data_types='close'`：默认值，计算收盘价的涨幅"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:143
msgid "准备回测数据"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:144
msgid "配置好选股策略以后，需要通过回测检验策略的表现，也就是调用沪深300和创业板两个指数的实际历史数据，进行模拟交易，看看模拟交易的结果是否能够跑赢大盘。在实际操作中，卖卖大盘指数不太容易，不过一般都可以很容易找到跟踪大盘指数的ETF基金来代替大盘，在这里为了简单起见，我们这里就直接投资于2011年1月1日一直到2020年12月31日之间的沪深300和创业板指数，假设交易费率为万分之一，双向收费，看看投资的结果如何。"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:146
msgid "前面我们已经了解过如何下载历史数据了，这里我们需要沪深300和创业板指数从2013年到2022年底之间的所有数据。"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:148
msgid "**注意** 在下载历史数据用于回测的时候，下载的数据需要比回测日期起点更多一些，例如，回测从2013年1月1日开始，实际需要的数据更多一些，因此下载数据的起点应该从2012年9月开始。关于这一点的详细分析，请参见[参考文档](http://qteasy.readthedocs.io)"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:151
msgid "使用下面的代码下载相应的历史数据："
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:159
msgid "确认数据是否下载成功："
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:164
msgid "![在这里插入图片描述](img/tutorial02-01.png)"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:166
msgid "![在这里插入图片描述](img/tutorial02-02.png)"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:168
msgid "配置回测参数"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:170
msgid "数据准备好之后，就可以开始配置回测参数并开始回测了。`qteasy`的策略回测完全是参数化的，在回测之前我们需要告诉系统所有的相关信息，例如投资的产品品种、投入资金的数量、回测开始日期和结束日期、回测过程的交易费用计算方法、交易批量等。我们可以通过`qt.configure()`对回测参数进行基本配置："
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:183
msgid "上面的配置含义如下"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:184
msgid "`asset_pool=['000300.SH', '399006.SZ']`：投资目标指数用列表形式给出，如果要投资其他的指数或ETF基金，直接传入证券代码即可，如果要从三个或更多的证券中选股，直接加入列表中即可"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:185
msgid "`invest_amounts=100000`： 投资金额为十万元，如果需要模拟多次分批投入，还可以传入一个列表，不过需要分别指定每次投入的具体日期"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:186
msgid "`asset_type='IDX'`： 投资标的类型：`'E'`代表股票， `'IDX'`代表指数，` 'FD'`代表基金，`'FT'`代表期货，`'OPT'`代表期权"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:187
msgid "`cost_rate_buy=0.0001`： 设置买入和卖出交易费用比例，`qteasy`还支持设置最低费用、固定费用等等，这里只简单设置费率即可"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:188
msgid "`cost_rate_sell=0.0001`："
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:189
msgid "`invest_start='20110101'`： 模拟交易开始日期"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:190
msgid "`invest_end='20201231'`：  模拟交易结束日期"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:191
msgid "`trade_batch_size=0`：  买入资产时最小交易批量，`0`代表可以交易任意份额，1代表只能交易整数份，这里可以输入任意大于`0`的数"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:192
msgid "`sell_batch_size=0`： 卖出资产时最小交易批量为`0`"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:194
msgid "`qteasy`还有其他的配置参数，参见[QTEASY文档](https://qteasy.readthedocs.io/zh/latest/)。"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:196
msgid "策略的回测结果"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:198
msgid "`qteasy`的策略回测非常简单，设置好所有的配置后，即可以开始回测了，我们可以调用`qt.run()`开始回测，回测的同时，我们开启可视化图表输出，并且开启交易明细记录："
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:206
msgid "等待片刻后，回测完成，`qteasy`会自动打印回测报告如下："
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:250
msgid "从回测的结果可以很容易看出，这个策略是跑赢了沪深300大盘指数的，在这十年间沪深300的年化收益率只有可怜的5%左右，甚至比某些收益较高的定期产品都不如，而我们这个策略的投资年化收益率达到了17.8%，十年间总资产从十万元达到了五十多万元，翻了五倍多"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:253
msgid "策略的进一步改进"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:254
msgid "我们的策略获得了初步的成功，不过，光看总回报率还不能完全说明问题，策略在整个十年间的表现如何呢？这就需要进一步分析，看看能否进一步改进这个策略。这时我们需要进一步查看回测的结果，尤其是可视化结果和交易明细记录，通过这些记录和报告来找到策略的不足和改进点。"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:256
msgid "可视化报告的使用"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:257
msgid "由于设置了`visual=True`，在回测报告的最后，还能看到运行结果的可视化图表报告如下： ![在这里插入图片描述](img/tutorial02-03.png) 可视化图表是`qteasy`的一个很有用的功能。首先我们可以看到回测的历史回报率曲线图。这个曲线图以百分比为单位，将投资组合的回报率曲线和一个参考曲线（默认情况下参考曲线是沪深300指数，可以通过`qt.configure(reference_asset='xxxxxx.xx')`来设置为不同的指数）的收益率对比。红色曲线为投资组合的收益率，而蓝色曲线为参考指数收益率。 在这张图的参考指数曲线上，会用红、绿色箭头标注所有的买卖点，同时，图表在持有仓位的时间区间填充上绿色，响应没有持仓（空仓）的时段会保持为白色，这样就很容易看出整个投资历史上组合的回报率，以及买卖、持仓的大致时段和比例。"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:262
msgid "紧接着第一张图表，后续五张图表都是历史曲线图，显示了投资回报的多种不同的评价指标，这里面我感觉最有用的是“underwater”图，也就是第六张图，显示了投资资产回撤的情况，这个表我们过一会来仔细分析。"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:264
msgid "最下面还有并列的三张图表，分别统计了历史上历年或历月的收益率，其中可以看到整个十年中有三年（2011年、2016年和2018年）的收益率是负的，其余年份均实现了正收益。"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:266
msgid "了解了可视化图表，我们来分析历史曲线，大家可以看着历史回报率曲线图，并开始设想，加入我按这个投资策略开始投资，从2015年6月3日开始，我的收益率会如何？结果是：到2016年6月13日亏损50.6%，然后一直到2020年2月才能解套！如下图： ![最大一次回撤持续了近五年](img/tutorial02-04.png) 同样，我们从第六张underwater图中也可以看到，在整个十年投资期间，总资产不断地出现回撤，50%回撤是最大最深的一次，但前期还有31%、22%的多次回撤，而且长度都不短，整个投资就是“长期被套牢，偶尔能翻盘”的状况，我相信，没有几个投资者能够熬得住这样的煎熬的，对吧？"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:266
msgid "最大一次回撤持续了近五年"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:270
msgid "![整个十年基本上都属于深度套牢状态](img/tutorial02-05.png) 如上图，整个十年间除2015年前后或者2020年下半年以外，几乎都处于潜水套牢状态。"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:270
msgid "整个十年基本上都属于深度套牢状态"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:273
msgid "因此，我们可以想办法改进一下这个策略，看看如何能够降低回撤，提升策略的性能。为此，我们需要仔细分析模拟交易回测过程中的每一笔交易，寻找降低回撤的办法。要查看回测交易的每一个细节，那就需要查看交易明细报告。"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:275
msgid "交易明细报告"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:276
msgid "我们在回测的时候，设置了`print_backtest_log=True`，因此系统会生成详细的交易明细报告。这份报告被保存在了`qteasy/log`路径下，可以看到包含两个报告，两个报告都保存为csv文件，便于用Excel打开： ![两个交易明细报告](img/tutorial02-06.png) 打开第一个文件可以看到交易日志，交易日志中记录了每一个交易日资金的变动，持股的变动、每种股票的交易明细等信息，不管是否有交易或持股变动，每天都有记录： ![在这里插入图片描述](img/tutorial02-07.png) 从上面的文件中可以看到，1月4日买入了31份沪深300指数，到1月5日收盘时卖出了持有的沪深300指数31份，并在1月6日收盘时买入87份创业板指，并在1月7日继续持有。。。 而打开trade_records.csv文件可以看到，这里记录了每一笔成交的交易，包括交易日期、买卖方向、交易份额、价格、总金额、交易费率等等信息，由于只记录有交易的实际发生，因此信息更加紧凑： ![在这里插入图片描述](img/tutorial02-08.png) 仔细分析上面的表格，会发现这个投资策略除了在换股的时候以外，都是满仓持有的，在2015年中的股灾期间也不例外，我们找到这段时间会发现，从2015年的6月18日开始，不管是沪深300指数还是创业板指数，他们的20日收益率都已经由正转负，表明后市已经开始下跌了，然而此时策略仍然坚定地持有创业板指，这是因为创业板指的跌幅要小于沪深300，也就是收益率大于沪深300： ![在这里插入图片描述](img/tutorial02-09.png) 所以其实这时候我们的策略仍然选择了正确的指数，只不过因为两个指数都在跌，我们的策略选择了跌的少的那一个持有，减少了我们的损失。"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:276
msgid "两个交易明细报告"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:287
msgid "那么，我们可否从这里出发改进我们的策略呢？思路很简单，我们可以加一条规则："
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:289
msgid "每天计算两个指数在过去20天的涨幅，也就是今天的价格相对于20天前价格的涨幅"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:290
msgid "如果选股日两个指数都小于0，那么我们第二天就空仓，一个指数都不持有"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:291
msgid "否则，选择涨幅较大的那个指数，在第二天持有，同时卖掉涨幅较小的指数"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:293
msgid "我们在原来的简单选股规则基础上增加了一条“过滤条件”，将两个指数都小于0的情况排除在外，好了，那么在`qteasy`中如何调整，以反映这个新的修改呢？"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:295
msgid "改进后的策略设置"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:297
msgid "`qteasy`的内置选股策略提供了一个过滤条件`condition`属性，默认条件下`condition='any'`，代表没有过滤条件，现在我们需要把小于0的收益率过滤掉，因此可以设置`condition='greater'`同时设置过滤范围`ubound=0`即可："
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:308
msgid "上面的设置跟前一节基本相同，增加了两个参数："
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:310
msgid "`condition='greater'`：含义是增加过滤条件，N日涨幅必须大于等于某个值才能参加选股，这个值在`ubound`参数中设置。也就是说排除掉小于这个值的股票，让其无法中选"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:311
msgid "`ubound=0`： 设置为0，这样只有涨幅大于等于0的指数才能被选中，当然还可以设置为其他浮点数"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:313
msgid "改进后的结果"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:314
msgid "同样按照前面的配置，直接执行`qt.run()`。这里直接放结果："
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:360
msgid "可视化图表如下： ![在这里插入图片描述](img/tutorial02-10.png) 从资产收益率图上可以看到，原来一片绿色（全程持仓）变成了白绿相间（白色区间空仓持币），资产回撤情况得到了大幅度优化：从原来的50%回撤降低到了20%左右。而且总回报率也大大提升："
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:364
msgid "资产总额从改进前的五十多万提高到一百万"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:365
msgid "总收益率从400%提升到了900%"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:366
msgid "年化收益率从17%提升到了26%"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:367
msgid "最大回撤从50%降低到了20%"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:369
msgid "通过查看交易记录可知，的确策略在2015年6月底的股灾期间保持空仓，躲避了单边下跌的行情。"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:370
#: ../../tutorials/4-build-in-strategies.md:494
msgid "本篇回顾"
msgstr ""

#: ../../tutorials/3-start-first-strategy.md:372
msgid "通过本教程，我们通过一个大小盘轮动交易策略的创建、回测、修改熟悉了解了`qteasy`的交易策略，知道如何通过引用内置交易策略，创建一个单策略交易员对象，并使交易员运行策略获得回测结果。从下一篇教程开始，我们将进一步详细讨论`qteasy`的内置交易策略，并且介绍组合策略的实现方式，在交易员对象中添加更多的策略并设定组合方式，通过策略组合实现更复杂的效果，并且了解更多策略控制和类型。"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:1
msgid "拼搭出一个比较复杂的策略"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:17
msgid "安装、配置`qteasy` —— 详情请参阅[QTEASY教程1](1-get-started.md)"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:18
msgid "设置了一个本地数据源，并已经将足够的历史数据下载到本地（包括交易日历、股票/基金/指数基本信息、股票/基金/指数的价格数据以及财务指标或其他财务数据——详情请参阅[QTEASY教程2](2-get-data.md)"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:19
msgid "学会创建交易员对象，使用一个内置交易策略并回测其历史表现，检查回测日志、明白如何调整策略的运行参数或可调参数，改进策略的表现——[QTEASY教程3](3-start-first-strategy.md)"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:21
msgid "在[QTEASY文档](https://qteasy.readthedocs.io/zh/latest/)中，还能找到更多关于如何创建交易员对象运行策略，使用历史数据回测策略，检查回测交易记录，修改策略等等相关内容。对`qteasy`的基本使用方法还不熟悉的同学，可以移步那里查看更多详细说明。"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:25
msgid "在本节中，我们将了解如果使用`qteasy`中更多的内置策略，如何使交易员同时运行多个交易策略，如何使用策略混合器`blender`来使用交易策略生成不同的组合策略，"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:28
msgid "目前`qteasy`支持超过70种内置交易策略，全部都是开箱即用，完整的内置交易策略清单请参见[参考文档](../references/4-build-in-strategy-blender.md)："
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:34
msgid "打印如下信息："
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:58
msgid "下面清单罗列了部分`qteasy`内置开箱即用的交易策略，完整的清单请参见[参考文档](../references/4-build-in-strategy-blender.md)"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`crossline`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`macd`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`dma`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`trix`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`cdl`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`TimingCDL`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "CDL择时策略，在K线图中找到符合要求的cdldoji模式<br />搜索历史数据窗口内出现的cdldoji模式（匹配度0～100之间），加总后/100，计算 等效cdldoji匹配数量，以匹配数量为交易信号。"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`bband`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`TimingBBand`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "布林带线交易策略，根据股价与布林带上轨和布林带下轨之间的关系确定多空，在价格上穿或下穿布林带线上下轨时产生交易信号。布林带线的均线类型不可选<br />1，当价格上穿上轨时，产生全仓买入信号<br />2，当价格下穿下轨时，产生全仓卖出信号"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`s-bband`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`SoftBBand`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "布林带线渐进交易策略，根据股价与布林带上轨和布林带下轨之间的关系确定多空，交易信号不是一次性产生的，而是逐步渐进买入和卖出。计算BBAND，检查价格是否超过BBAND的上轨或下轨：<br />1，当价格大于上轨后，每天产生10%的比例买入交易信号<br />2，当价格低于下轨后，每天产生33%的比例卖出交易信号"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`sarext`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`TimingSAREXT`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "扩展抛物线SAR策略，当指标大于0时发出买入信号，当指标小于0时发出卖出信号"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`ssma`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`sdema`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`SCRSDEMA`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "单均线交叉策略——DEMA均线(双重指数平滑移动平均线)：根据股价与DEMA均线的相对位置设定持仓比例"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`sema`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "..."
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "完整的内置策略清单请见[参考文档](../references/4-build-in-strategy-blender.md)"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:76
msgid "如果需要查看每一个内置交易策略的详细解释，例如策略参数的含义、信号生成规则，可以查看每一个交易策略的`doc-string`："
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:78
msgid "例如："
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:83
msgid "可以看到"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:112
msgid "在`ipython`等交互式`python`环境中，也可以使用`?`来显示内置交易策略的详细信息，例如："
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:118
msgid "可以看到："
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:163
msgid "多重策略以及策略组合"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:165
msgid "在`qteasy`中，一个`Operator`交易员对象可以同时运行多个交易策略。这些交易策略在运行的时候，都会分别提取各自所需的历史数据，独立生成不同的交易信号，这些交易信号会被组合成一组交易信号，统一执行。"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:167
msgid "利用这种特性，用户可以在一个交易员对象中同时运行多个各有侧重的交易策略，例如，一个交易策略监控个股的股价，根据股价产生择信号，第二个交易策略专门负责监控大盘走势，通过大盘走势决定整体仓位。第三个交易策略专门负责止盈止损，在特定时刻止损。最终的交易信号以第一个交易策略为主，但受到第二个策略的节制，必要时会被第三个策略完全控制。"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:169
msgid "或者，用户也可以很容易地制定出一个“委员会”策略，在一个综合性策略中由多个策略独立地做出交易决策，最终的交易信号由所有子策略组成的”委员会“投票决定，投票的方式可以是简单多数、绝对多数、加权投票结果等等。"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:171
msgid "上述交易策略组合中，每一个独立的交易策略都很简单，很容易定义，而将他们组合起来，又能发挥更大的作用。同时每一个子策略都是独立的，可以自由组合出复杂的综合性交易策略。这样可以避免不断地重复开发策略，只需要对子策略重新排列组合，重新定义组合方式，就可以快速地搭建一系列的复杂综合性交易策略。相信这样能够极大地提高交易策略的搭建效率，缩短周期。时间就是金钱。"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:173
msgid "不过，在一个`Operator`对象中，不同策略生成的交易信号可能运行的时机是不同的，例如，某些策略在开盘时运行，生成开盘价交易信号，而另一些策略在收盘前运行，生成的是收盘价交易信号，那么运行在不同时机的策略，生成的信号当然不应该混合。但只要是同时运行的交易策略生成的信号，都应该全部混合。"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:175
msgid "交易信号的混合即交易信号的各种运算或函数，从简单的逻辑运算、加减运算一直到复杂的自定义函数，只要能够应用于一个`ndarray`的函数，理论上都可以用于混合交易信号，只要最终输出的交易信号有意义即可。"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:176
msgid "定义策略组合方式`blender`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:178
msgid "`qteasy`中的组合策略是由`blender`实现的。在一个`Operator`中，如果策略的数量多于1个，就必须定义一个`blender`。如果没有明确定义`blender`，而策略的数量超过1个时，`qteasy`会在运行`Operator`的时候创建一个默认的`blender`，但是为了让多重策略正确运行，用户需要自行定义`blender`。"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:180
msgid "`blender expression`是用户自行定义的一个组合表达式，用户使用这个表达式确定不同交易策略的组合方式。这个组合表达式使用四则运算符、逻辑运算符、函数等符号规定策略信号是如何组合的。`blender`表达式中可以包括以下元素："
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:182
#: ../../tutorials/4-build-in-strategies.md:228
msgid "`blender`表达式中支持的函数如下："
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "元素"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "示例"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "策略序号"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`s0, s1...`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "以s开头，数字结尾的字符串，数字为`Operator`中的策略的序号，代表这个策略生成的交易信号"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "数字"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`-1.35`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "任何合法的数字，参与表达式运算的数字"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "运算符"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`+`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "包括`+ - * / ^`等数学运算符"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "逻辑运算符"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`and`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "支持`&`/`~`以及`and`/`or`/`not`等逻辑运算符"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "函数"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`sum()`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "表达式支持多种函数，支持的函数参见后表"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "括号"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`()`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "组合运算"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:194
msgid "`blender`示例"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:196
msgid "当一个`Operator`对象中有三个交易策略时（其序号分别为`s0`/`s1`/`s2`），按照以下方式定义的`blender`都是合法可用的，同时使用`Operator.set_blender()`来设置`blender`："
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:198
msgid "使用四则运算符定义blender表达式"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:200
msgid "`'s0 + s1 + s2'`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:202
msgid "此时三个交易策略生成的交易信号会被加起来，成为最终的交易信号，如果策略0的结果为买入10%，策略1结果为买入10%，策略2结果为买入30%，则最终的结果为买入50%"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:204
msgid "使用逻辑运算符定义blender表达式："
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:206
msgid "`'s0 and s1 and s2'`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:208
msgid "表示只有当交易策略1、2、3都出现交易信号的时候，才会最终形成交易信号。如策略1的结果为买入，策略2结果为买入，而策略3没有交易信号，则最终的结果为没有交易信号。"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:210
msgid "blender表达式中还可以包含括号和一些函数："
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:212
msgid "`'max(s0, s1) + s2'`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:214
msgid "表示策略1、2的结果中最大值与策略3的结果相加，成为最终交易信号。如果策略1的结果为买入10%，策略2结果为买入20%，策略3结果为买入30%，最终的结果为买入50%"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:216
msgid "blender 表达式中每个策略可以出现不止一次，也可以出现纯数字："
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:218
msgid "`'(0.5 * s0 + 1.0 * s1 + 1.5 * s2) / 3 * min(s0, s1, s2)'`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:220
msgid "上面的`blender`表达式表示：首先计算三个策略信号的加权平均（权重分别为0.5、1.0、1.5），然后再乘以三个信号的最小值"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:222
msgid "blender 表达式中函数的操作参数在函数名中定义："
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:224
msgid "`'clip_-0.5_0.5(s0 + s1 + s2) + pos_2_0.2(s0, s1, s2)'`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:226
msgid "上面的`blender`表达式定义了两种不同的函数操作，分别得到结果后相加得到最终结果。第一个函数是范围剪切，将三组策略信号相加后，剪切掉小于-0.5的信号值以及大于0.5的信号值，得到计算结果；第二个函数是仓位判断函数，统计三组信号中持仓大于0.2的时间段，将其定义为“多头”，然后再统计每一个时间段三个策略中持多头建议的数量，如果超过两个策略持多头建议，则输出满仓多头，否则输出空仓。"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "表达式示例"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`abs`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`abs(s0, s1, s2)`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "绝对值函数<br />计算所有交易信号的绝对值<br />输入信号的数量不限"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`avg`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`avg(s0, s1, s2)`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "平均值函数<br />计算所有交易信号的平均值<br />输入信号的数量不限"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`avgpos`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`avgpos_N_T(s0, s1, s2)`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "平均值累计函数<br />当交易信号为持仓目标信号时，统计同一时间产生非空仓信号（输出信号绝对值>T）的个数，当空头/多头信号的数量大于N时，输出所有空头/多头信号的平均值，否则输出0.<br />输入信号的数量不限"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`ceil`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`ceil(s0)`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "向上取整函数<br />交易信号向上取整<br />只能输入一个交易信号"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`clip`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`clip_U_L(s0)`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "范围剪切函数<br />剪切超过范围的信号值，剪切上下范围在函数名中定义<br />只能输入一个交易信号"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`combo`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`combo(s0, s1, s2)`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "组合值函数<br />输出所有交易信号加总的值<br />输入信号的数量不限"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`committee`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`cmt_N_T(s0, s1, s2)`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "委员会函数（等同于累计持仓函数））<br />当交易信号为持仓目标信号时，统计同一时间产生非空仓信号（输出信号绝对值>T）的个数数，当多头/空头信号的数量大于N时，输出-1/1，否则输出0.<br />输入信号的数量不限"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`exp`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`exp(s0)`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "exp函数<br />计算e的信号次幂<br />只能输入一个交易信号"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`floor`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`floor(s0)`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "向下取整函数<br />交易信号向下取整<br />只能输入一个交易信号"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`log`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`log(s0)`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "对数函数<br />计算以e为底的对数值<br />只能输入一个交易信号"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`log10`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`log10(s0)`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "以10为底的对数函数<br />计算以10为底的对数值<br />只能输入一个交易信号"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`max`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`max(s0, s1, s2)`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "最大值函数<br />计算所有交易信号的最大值<br />输入信号的数量不限"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`min`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`min(s0, s1, s2)`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "最小值函数<br />计算所有交易信号的最小值<br />输入信号的数量不限"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`pos`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`pos_N_T(s0, s1, s2)`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "累计持仓函数<br />当交易信号为持仓目标信号时，统计同一时间产生非空仓信号（输出信号绝对值>T）的个数数，当多头/空头信号的数量大于N时，输出-1/1，否则输出0.<br />输入信号的数量不限"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`position`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`position_N_T(s0, s1, s2)`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`pow`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`pow(s0, s1, s2)`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "幂函数<br />计算第一个交易信号的第二个信号次幂即sig0^sig1<br />输入信号的数量只能为两个"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`power`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`power(s0, s1, s2)`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`sqrt`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`sqrt(s0)`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "平方根函数<br />交易信号的平方根<br />只能输入一个交易信号"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`str`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`str_T(s0, s1, s2)`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "强度累计函数<br />将所有交易信号加总，当信号强度超过T时，输出1，否则输出0<br />输入信号的数量不限"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`strength`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`strength_T(s0, s1, s2)`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`sum`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`sum(s0, s1, s2)`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`unify`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`unify(s0)`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "均一化函数<br />均一化交易信号，等比缩放同一行的交易信号使每一行的总和为1<br />只能输入一个交易信号"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`vote`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "`vote_N_T(s0, s1, s2)`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:0
msgid "委员会投票函数（等同于累计持仓函数）<br />当交易信号为持仓目标信号时，统计同一时间产生非空仓信号（输出信号绝对值>T）的个数数，当多头/空头信号的数量大于N时，输出-1/1，否则输出0.<br />输入信号的数量不限"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:257
msgid "以下方法可以被用来设置或获取策略的`blender`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:259
msgid "`operator.set_blender(blender=None, price_type=None)`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:260
msgid "设置`blender`，直接传入一个表达式`blender expression`，这个表达式会被自动解析后用于组合交易策略。"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:262
msgid "`operator.view_blender()`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:263
msgid "查看`blender`, 注意此时为了便于人眼识别，混合器表达式中的策略代码`s0`,`s1`,`s2`会被自动替换为具体的策略ID，如下面例子所示："
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:271
msgid "上面例子中的`s0`,`s1`,`s2`分别被`dma`、`macd`、`trix`代替，但如果`Operator`中包含多个相同的策略，它们会被自动分配不同的策略ID，以示区别："
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:279
msgid "`blender`使用示例"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:281
msgid "下面使用一个例子来演示`blender`的工作方式："
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:283
msgid "我们生成一个交易员对象，同时运行五个`DMA`交易策略，但五个交易策略分别有不同的可调参数，这时，我们可以理解为这个交易员同时运行五个同样的交易逻辑，但这五个交易逻辑被配置了不同的参数，因此在同样的输入条件下，产生不同的交易信号，意味着五个交易策略各有侧重，有的擅长于抓取长期变量，有的善于追踪短期趋势。"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:285
msgid "下面，同样是这五个交易策略，但我们会用三个不同的例子，来展示三种不同的混合方式，向您展示，即使完全相同的交易策略和交易参数，在同一段历史区间，不同的混合方式同样能影响最终的交易结果。"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:287
msgid "第一种混合方式：加权平均混合"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:289
msgid "第一种混合方式将五个交易策略的结果进行加权平均，混合表达式如下，其中的权值可以自行调整："
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:291
msgid "`(0.8*s0+1.2*s1+2*s2+0.5*s3+1.5*s4)/5`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:359
msgid "![png](../references/img/output_10_1.png)"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:361
msgid "如果仔细观察上面生成的收益曲线图，可以注意到图示的背景上绘制了深浅不同的绿色条纹，这些条纹代表该段时间段里的持仓比例，白色代表空仓持币，即完全不持有任何股票，而最深的绿色代表100%持股，介于中间的绿色代表0～100%之间的持股比例，持股比例越高，条纹的颜色越深。"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:363
msgid "从图中可以看到，整个交易历史区间存在着深浅不一的绿色，如果您非常仔细地检查每一个持股区间，会发现这些区间的持股比例正好对应着当时五个交易策略的混合结果：当全部交易策略都\"一致决定\"全仓买入时，它们的加权平均结果就是100%买入，但只要有一个或多个策略决定持有空仓，最终加权平均的结果就是持有一定百分比的股票，这个百分比等于五个策略信号的加权平均结果。最终的结果就是持仓比例在0%～100%之间波动，完全空仓和完全满仓的时间都不长。"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:365
msgid "这也意味着我们不能通过空仓来完全避免单边下跌行情，不过，始终保持一定仓位却能更好地抓住上升通道。"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:367
msgid "同时，您也应该可以观察到，由于仓位是灵活调整的，在单边下跌行情中的仓位（绿色的深浅幅度）明显更低，上涨行情仓位更高，这正是我们所期望的。"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:369
msgid "接下来，让我们来看下一种完全不同的混合方式："
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:371
msgid "第二种混合方式：委员会投票"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:373
msgid "这种方式让同样五个交易策略组成一个\"委员会\"，通过平等投票来决定仓位，且仓位必须是\"非黑即白\"的两种结果之一：要么满仓，要么空仓。其表达式如下："
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:375
msgid "`pos_3_0(s0, s1, s2, s3, s4)`"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:430
msgid "![png](../references/img/output_11_1.png)"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:432
msgid "您一定看到了，这一次的输出结果跟前一次有了很大区别：上一次回测时持仓是渐变的，而这一次是非黑即白的，要么是满仓，要么是纯粹空仓，您如果仔细分析交易日志，会发现只有当三个交易策略举手赞成满仓时，才会满仓，其余时间空仓。因此在单边下跌行情中的收益曲线是一条直线。但满仓时如果股票下跌，也没有办法通过适当减仓来降低损失。"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:434
msgid "接下来，我们仍然使用这个委员会，但是现在只要有两票投满仓时，最终就会满仓："
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:436
msgid "第三种混合方式：委员会投票"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:490
msgid "![png](../references/img/output_12_1_2.png)"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:492
msgid "对比第二张图表和第三张图表，您可以发现，满仓的区间明显变长了，这是因为原来需要三张赞成票才能满仓的策略，现在只要两张赞成票就可以了，因此更容易出现满仓的结果"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:496
msgid "好了，相信到了这里，您应该会对交易策略的混合有了一个基本的理解了。我们的教程还会继续，`qteasy`还有更多的方式实现您希望的交易策略，实际上，尽管`qteasy`的内核被设计为一个有利于高速回测和高速执行的向量化的策略内核，但仍然考虑到了足够的灵活性，理论上您可以实现您所设想的任何类型的交易策略。"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:498
#: ../../tutorials/5-first-self-defined-strategy.md:28
#: ../../tutorials/7-more-complicated-self-define-srtategy.md:34
msgid "同时，`qteasy`的回测框架也做了相当多的特殊设计，可以完全避免您无意中在交易策略中导入\"未来函数\"，确保您的交易策略在回测时完全基于过去的数据，同时也使用了很多预处理技术以及JIT技术对内核关键函数进行了编译，以实现不亚于C语言的运行速度。"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:500
#: ../../tutorials/7-more-complicated-self-define-srtategy.md:36
msgid "不过，为了实现理论上无限可能的交易策略，仅仅使用内置交易策略以及策略混合就不一定够用了，一些特定的交易策略，或者一些特别复杂的交易策略是无法通过内置策略混合而成的，这就需要我们使用`qteasy`提供的`Strategy`基类，基于一定的规则创建一个自定义交易策略了。"
msgstr ""

#: ../../tutorials/4-build-in-strategies.md:502
msgid "在`qteasy`教程的下一节，我们将用一个例子来介绍如何创建一个自定义交易策略，如何定义策略的基本参数，如何定义策略所需的数据类型，如何设置交易信号的生成逻辑。。。"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:1
msgid "使用qteasy创建自定义交易策略"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:17
#: ../../tutorials/6-more-self-defined-strategies.md:18
#: ../../tutorials/7-more-complicated-self-define-srtategy.md:24
msgid "**安装、配置`qteasy`** —— [QTEASY教程1](1-get-started.md)"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:18
#: ../../tutorials/6-more-self-defined-strategies.md:19
#: ../../tutorials/7-more-complicated-self-define-srtategy.md:25
msgid "**设置了一个本地数据源**，并已经将足够的历史数据下载到本地——[QTEASY教程2](2-get-data.md)"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:19
#: ../../tutorials/6-more-self-defined-strategies.md:20
#: ../../tutorials/7-more-complicated-self-define-srtategy.md:26
msgid "**学会创建交易员对象，使用内置交易策略**，——[QTEASY教程3](3-start-first-strategy.md)"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:20
#: ../../tutorials/6-more-self-defined-strategies.md:21
#: ../../tutorials/7-more-complicated-self-define-srtategy.md:27
msgid "**学会使用混合器，将多个简单策略混合成较为复杂的交易策略**——[QTEASY教程4](4-build-in-strategies.md)"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:22
#: ../../tutorials/6-more-self-defined-strategies.md:24
#: ../../tutorials/7-more-complicated-self-define-srtategy.md:30
msgid "在[QTEASY文档](https://qteasy.readthedocs.io/zh/latest/)中，还能找到更多关于使用内置交易策略、创建自定义策略等等相关内容。对`qteasy`的基本使用方法还不熟悉的同学，可以移步那里查看更多详细说明。"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:26
#: ../../tutorials/7-more-complicated-self-define-srtategy.md:32
msgid "`qteasy`的内核被设计为一个兼顾高速执行以及足够的灵活性的框架，理论上您可以实现您所设想的任何类型的交易策略。"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:30
msgid "不过，为了实现理论上无限可能的交易策略，仅仅使用内置交易策略以及策略混合就不一定够用了，一些特定的交易策略，或者一些特别复杂的交易策略是无法通过内置策略混合而成的，这就需要我们使用`qteasy`提供的`Strategy`基类，基于一定的规则创建一个自定义交易策略。"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:32
msgid "在本节中，我们将介绍`qteasy`的交易策略基类，通过几个具体的例子详细讲解如何基于这几个基类，创建一个只属于您自己的交易策略。为了循序渐进，我们先从一个较为简单的例子开始。"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:34
msgid "自定义策略的实现方法"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:36
msgid "在量化交易的工作流程中，一个交易策略实际上就是一个函数，这个函数以已知的信息作为输入，通过一系列逻辑推演，输出交易决策。不管什么技术流派，不管哪种交易风格，不管任何分析方法，交易策略的最根本的定义，就是如此。"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:38
msgid "![在这里插入图片描述](../img/Essence_of_Strategy.png)"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:41
msgid "比如："
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:43
msgid "技术分析派利用过去的股票价格（**输入数据**）计算技术指标（**逻辑推演**），进行买入/卖出操作（**交易决策**）"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:44
msgid "价值投资派利用上市公司的各项指标（**输入数据**），分析公司的成长潜力（**逻辑推演**），决定买入/卖出哪一支股票（**交易决策**）"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:45
msgid "宏观分析者即使不关心个股的价格，也需要参考热点新闻、市场景气（仍然是**输入数据**），分析市场的整体趋势（**逻辑推演**），决定是否入市（**交易决策**）"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:46
msgid "高频或超高频的套利交易，也需要根据短期内价格的实时变化（**输入数据**），分析套利空间大小（**逻辑推演**），以便迅速介入操作（**交易决策**）"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:48
msgid "上面的交易策略，如果以较高的频率，跟踪少数投资品种，就是所谓的“**择时交易策略**”，如果以较低的频率，跟踪大量的投资品种，就是所谓的“**选股策略**”。"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:50
msgid "总之，一切量化交易，都是一套**定期运行的逻辑推演，在每次运行时，提取当时的最新数据作为输入，输出一套交易决策**。如此反复运行，形成稳定的交易操作流水，概莫能外，这就是交易策略的抽象概念。"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:52
msgid "使用 `qteasy` 的 `Strategy` 策略类"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:54
msgid "`qteasy`的交易策略就是基于上面的概念定义的。qteasy提供了策略基类Strategy，定义交易策略时只需要继承Strategy类，并在初始化时定义下面三个方面的内容："
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:56
msgid "**策略的运行时机** —— 策略何时运行，以什么频率运行，例如，每分钟运行一次，每天运行一次，是开盘时运行，还是收盘时运行？在`qteasy`中，策略的运行时机是以策略的属性`Strategy.strategy_run_timing`来定义"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:57
msgid "**策略需要的数据** ——策略需要的数据输入；例如，需要过去10天的日K线数据，还是过去一年的市盈率？在`qteasy`中，策略所需的数据量可以以`Strategy.strategy_data_types` 等属性完全自由定义，并指定数据类型、频率以及窗口长度"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:58
msgid "**策略的逻辑** ——通过重写`Strategy.realize()`方法，用户可以自由定义如何使用输入数据，产生交易决策。"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:60
msgid "除了上面跟策略有关的信息以外，其余所有的工作`qteasy`都已经做好了，所有的交易数据都会根据策略属性被自动打包成一个`ndarray`数组，可以很方便地提取并使用；同一个交易策略，在实盘运行时会自动抽取交易数据，根据定义好的策略生成交易信号，在回测时也会自动提取历史数据，自动生成历史数据切片，不会形成未来函数。同时，所有交易数据都会"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:62
msgid "因此，在`qteasy`中的策略自定义非常简单："
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:64
msgid "**`__init__()`** 在此方法中定义策略的运行参数，包括运行的频率、视窗长度、使用的数据类型、可调参数数量类型等"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:65
msgid "**`realize()`** 在此方法中定义策略的运行逻辑：提取自动生成的交易数据，根据数据生成交易信号"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:67
msgid "![在这里插入图片描述](../img/Strategy_Class_Illustration.png)"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:69
msgid "除了上面所说的策略属性以外，自定义策略同样拥有与内置交易策略相同的基本属性，例如可调参数数量、类型等等，因为它们与内置交易策略相同，在这里就不赘述了。"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:70
msgid "三种不同的自定义策略基类"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:72
msgid "`qteasy`提供了三种不同的策略类，便于用户针对不同的情况创建自定义策略。"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:74
msgid "**`GeneralStg`**: 通用交易策略类，用户需要在`realize()`方法中给出所有交易资产的交易决策信号"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:75
msgid "**`FactorSorter`**: 因子选股类，用户只需要在`realize()`方法中定义出选股因子，便可以通过对象属性实现多种选股动作"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:76
msgid "**`RuleIterator`**: 循环规则类，用户只要针对一支股票定义选股或择时规则，则同样的规则会被循环作用于所有的股票，而且不同股票可以定义不同的参数"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:78
msgid "三种交易策略基类的属性、方法都完全相同，区别仅在于`realize()`方法的定义。"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:80
msgid "下面，我们通过几个循序渐进的例子来了解如何创建自定义策略。"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:81
msgid "定义一个双均线择时交易策略"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:83
msgid "我们的第一个例子是最简单的双均线择时交易策略，这是一个最经典的择时交易策略。 这个均线择时策略有两个可调参数："
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:85
msgid "FMA 快均线周期"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:86
msgid "SMA 慢均线周期 策略根据过去一段时间的收盘价，计算上述两个周期产生的简单移动平均线，当两根均线发生交叉时产生交易信号："
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:89
msgid "当快均线自下而上穿过上边界，发出全仓买入信号"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:90
msgid "当快均线自上而下穿过上边界，发出全部卖出信号"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:92
msgid "![在这里插入图片描述](img/MAV_Cross_Strategy.png)"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:94
msgid "这个策略的逻辑非常简单。那我们怎么定义这个策略呢？首先，我们需要决定使用哪一种交易策略基类。很多情况下，三种交易策略基类都可以用来生成同样的交易策略，只不过某些基类针对特定类型的策略提前做了一些定义，因而可以进一步简化策略的代码。这个策略是一个典型的择时策略，是针对不同投资品种应用同一规则的策略类型，因此，我们可以先用`RuleIterator`策略类来建立策略。在后面的例子中我们会陆续讲到另外两种策略类。"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:96
msgid "接下来，我们把这个策略的三大要素明确一下："
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:98
msgid "**策略的运行时机** —— 为了简单，我们定义这个策略每天收盘时运行"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:99
msgid "**策略需要的数据** ——为了计算两条均线，我们需要每次策略运行时的历史收盘价(`“close”`)，而且需要过去连续至少SMA天的历史数据，才足够用来计算SMA慢均线"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:100
msgid "**策略的逻辑** ——提取收盘价后，首先计算两条均线，然后判断最近一天的均线是否有上穿/下穿。具体说来，就是比较昨天和今天两个移动平均价的相对关系，如果昨天SMA大于FMA，而今天SMA就小于FMA了，说明FMA从下方上穿了SMA，应该产生全仓买入信号，这个信号为1，如果情况正好相反，则输出全仓卖出信号-1，其他情况下则输出0，没有交易信号。"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:102
msgid "有了上面的准备，那我们来看看策略代码如何定义。一个最基本的策略代码，第一步就是继承策略基类（这里是`RuleIterator`），创建一个自定义类："
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:119
msgid "好了，上面几行代码，就是我们第一个自定义交易策略的全部框架了，在这个框架中填充属性，补充逻辑，就能成为一个完整的交易策略。怎么做呢，我们首先定义这个策略的最基本属性——名称、描述、以及可调参数："
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:121
msgid "名称和描述都是策略的信息，在后续调用时方便了解策略的用途，咱们按照喜好定义即可，比较关键的属性是可调参数。"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:123
msgid "在我们这个策略中，我们希望快均线和慢均线的计算参数是可调的，因为这两个参数直接影响了快慢均线的具体位置，从而直接影响两条均线的交叉点，从而形成不同的买卖点，参见下面两张图，分别显示了同一只股票在同一段时间内不同速度均线的交叉情况，当均线的计算周期不同时，产生的买卖点也完全不同："
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:125
msgid "![在这里插入图片描述](img/MAV_Cross_Strategy.png) 上图中均线周期分别为15天/40天，产生三次买入、两次卖出信号 ![在这里插入图片描述](img/MAV_Cross_Strategy2.png) 上图中均线周期分别为5天/50天，产生两次买入、一次卖出信号"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:130
msgid "既然均线周期直接影响到策略的表现，因此我们自然希望找到最优的均线周期组合（参数组合），使得策略的表现最佳。为了达到这个目的，`qteasy`允许用户将这些参数定义为“可调参数”，并提供优化算法来寻找最优参数。对所有的内置交易策略来说，可调参数的数量和含义是定义好的，用户不能修改，但是在自定义策略这里，用户就有了很大的自由度，理论上讲，策略运行过程中用到的任何变量，都可以被定义为可调参数。"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:132
msgid "在这里，我们将快慢均线的周期定义为可调参数，在策略属性中进行以下定义"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:145
msgid "定义策略运行时机"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:147
msgid "接下来，我们开始定义策略的运行时机。运行时机由两个属性定义： 策略的运行时机可以定义为`‘close’`（收盘时）或者`‘open’`（开盘时）。这里的开盘与收盘并不仅仅指每个交易日的开盘与收盘，而是指广义的区间结束和开始，如果策略被定义为每分钟运行一次，那么`close`指的是在这个每分钟时间区间的结束时运行策略，也就是每分钟的最后一秒运行策略。因此，`timing`和`freq`两个属性共同定义了策略的运行时机。"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:150
msgid "如下面的属性定义了策略在每个交易日收盘时运行（实盘运行时策略会在收盘前一分钟运行以避免收盘后无法提交交易委托）"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:160
msgid "定义策略需要的数据"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:161
msgid "策略需要的数据由三个属性确定，分别定义数据类型（ID），数据频率以及采样窗口长度。"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:163
msgid "定义好策略数据后，`qteasy`会自动将窗口内的数据打包送入策略`realize()`函数，如果在回测的过程中，所有历史数据会根据同样的规则分别打包成一系列的数据窗口，因此，不管是回测还是实盘运行，`realize()`函数接受到的历史数据格式完全相同，处理方式也完全相同，确保实盘和回测运行的一致性，也避免了回测中可能出现的未来函数："
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:165
msgid "![在这里插入图片描述](img/Data_window_explained.png)"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:167
msgid "数据类型的定义如下，我们需要过去201天的每日收盘价，之所以需要201天的收盘价，是因为我们定义了可调参数的最大范围为200，为了计算周期为200的移动均线，需要201天的收盘价"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:178
msgid "至此，自定义交易策略的所有重要属性就全部定义好了。接下来我们来定义策略的实现。"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:180
msgid "自定义交易策略的实现：`realize()`"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:182
msgid "在`realize()`方法中，我们需要做三件事情，我们一件件解决："
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:184
msgid "获取历史数据"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:185
msgid "获取可调参数"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:186
msgid "编写逻辑，产生输出"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:188
msgid "获取历史数据和可调参数值："
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:189
msgid "`realize()`方法的输入参数是一个标准定义，前面已经提到过了，所有需要的数据都会自动打包传入，这些数据就是参数`h`。`h`代表`“history data”`"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:191
msgid "`h`的形态是一个`Numpy` `ndarray`，在`RuleIterator`策略中，它是一个二维数组，有N行、M列，其中每一列包含一种历史数据，每一行包含一个周期的数据。 在这个例子中，由于我们定义的数据类型为过去201天的收盘价，只有一种数据类型，因此h有201行，1列，每一行是一天的收盘价，数据是升序排列的，因此第一行为最早的数据，最后一行为最近的数据。我们要获取历史数据，直接从`ndarray`中切片即可。"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:194
msgid "前面已经提过，这个策略的可调参数就是均线的计算周期，因此，为了使用可调参数计算周期，我们需要取得可调参数的值，这些值保存在策略的pars属性中，通过`self.pars`即可获取。"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:204
msgid "到这里，实现策略逻辑所需要的元素都备齐了，接下来我们可以开始实现策略逻辑。"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:206
msgid "我们需要首先计算两组移动平均价，如果用户安装了`ta-lib`库，那么可以直接调用`ta-lib`的`SMA`函数计算移动平均价，如果没有安装，现在也没有太大关系，因为`qteasy`为用户提供了免`ta-lib`版本的`SMA`函数，（并不是所有的技术指标都有免`ta-lib`版本，详情参见参考文档）可以直接引用计算。"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:221
msgid "计算出移动均线后，我们可以直接在`realize`方法中定义策略的输出，也就是交易决策。"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:223
msgid "对于`RuleIterator`类策略，不管我们的策略同时作用于多少支股票，我们都只需要定义一套规则即可，是为“规则迭代”，因此，我们只需要输出一个数字，代表交易决策即可。这个数字会被`qteasy`自动转化为不同的交易委托单。转化的规则由`Operator`对象的工作模式确定，关于这一点在前面的教程中已经介绍过了，这里不再赘述。"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:225
msgid "总之，如果我们计划让`Operator`工作在`“PS”`模式下，那么只需要在应当买入的当天，产生交易信号“1”，在应当卖出的当天，产生交易信号“-1”即可，如果不希望交易，则输出“0”："
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:241
msgid "至此，这个交易策略就定义完成了！`qteasy`会完成所有背后的复杂工作，用户仅需要集中精力解决策略的数据和逻辑定义即可。完整代码如下（为节约篇幅，删除了所有注释）："
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:282
msgid "接下来，我们就可以像使用任何内置交易策略一样使用这个自定义策略了。"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:288
msgid "让我们看看这个策略的回测结果。"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:290
msgid "第一个策略的回测结果"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:292
msgid "策略回测的参数设置与内置交易策略完全一样"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:309
msgid "回测的结果如下："
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:311
msgid "![在这里插入图片描述](../examples/img/output_3_2.png)"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:313
msgid "下面，我们可以尝试一下修改策略的可调参数，再重新跑一遍回测，回测区间与前一次相同："
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:328
msgid "可以看到，改变参数后，策略的回测结果大为改观：要了解如何进行策略参数优化，请参考本教程的后续章节"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:330
msgid "![在这里插入图片描述](../examples/img/output_5_1.png)"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:332
msgid "至此，我们已经实现了一个简单的自定义择时交易策略，那么另外两种策略类如何实现呢？下面我们再用两个例子来说明。"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:334
#: ../../tutorials/6-more-self-defined-strategies.md:443
#: ../../tutorials/7-more-complicated-self-define-srtategy.md:246
msgid "本节回顾"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:337
msgid "在这一节中，我们了解了`qteasy`中对交易策略的抽象定义，了解了一个交易策略所包含的基本要素以及它们的定义方法，并且通过一个最简单的例子，实际创建了一个自定义双均线交易策略。"
msgstr ""

#: ../../tutorials/5-first-self-defined-strategy.md:339
msgid "接下来，我们还将继续介绍自定义交易策略，因为相关的内容比较多，所以自定义交易策略相关的教程将占用三个章节。在下一章节中，我们将学习如何使用另外两种自定义策略基类（`FactorSorter`因子选股基类和`GeneralStg`通用策略基类）来创建交易策略。接着，我们将再用一个章节的篇幅，来介绍一个比较复杂的自定义交易策略，展示`qteasy`的灵活性，让我们下一节见！"
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:2
msgid "创建自定义因子选股交易策略"
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:22
msgid "**了解如何自定义交易策略**——[QTEASY教程5](5-first-self-defined-strategy.md)"
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:28
msgid "在本节中，我们将承接上一节开始的内容，介绍`qteasy`的交易策略基类，在介绍过一个最简单的择时交易策略类以后，我们将介绍如何使用`qteasy`提供的另外两种策略基类，创建一个多因子选股策略。"
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:30
msgid "为了提供足够的使用便利性，`qteasy`的提供的各种策略基类本质上并无区别，只是为了减少用户编码工作量而提供的预处理形式，甚至可以将不同的交易策略基类理解成，为了特定交易策略设计的“语法糖”，因此，同一交易策略往往可以用多种不同的交易策略基类实现，因此，在本节中，我们将用两种不同的策略基类来实现一个Alpha选股交易策略。"
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:31
msgid "Alpha选股策略的选股思想"
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:33
msgid "我们在这里讨论的Alpha选股策略是一个低频运行的选股策略，这个策略可以每周或者每月运行一次，每次选股时会遍历HS300指数的全部成分股，依照一定的标准将这300支股票进行优先级排序，从中选择出排位靠前的30支股票，等权持有，也就是说，每个月进行一次调仓换股，调仓时将排名靠后的股票卖掉，买入排名靠前的股票，并确保股票的持有份额相同。"
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:35
msgid "Alpha选股策略的排名依据每一支股票的两个财务指标：EV（企业市场价值）以及EBITDA（息税折旧摊销前利润）来计算，对每一支股票计算EV与EBITDA的比值，当这个比值大于0的时候，说明该上市公司是盈利的（因为EBITDA为正）。这时，这个比值代表该公司每赚到一块钱利润，需要投入的企业总价值。自然，这个比值越低越好。例如，下面两家上市公司数据如下："
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:37
msgid "A公司的EBITDA为一千万，而企业市场价值为一百亿，EV/EBITDA=1000.。说明该公司每一千元的市场价值可以挣到一元钱利润"
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:38
msgid "B公司的EBITDA同样为一千万，企业市场价值为一千亿，EV/EBITDA=10000，说明该公司每一万元的市场价值可以挣到一元钱利润"
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:40
msgid "从常理分析，我们自然会觉得A公司比较好，因为靠着较少的公司市场价值，就挣到了同样的利润，这时我们认为A公司的排名比较靠前。"
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:42
msgid "按照上面的规则，我们在每个月的最后一天，将HS300成分股的所有上市公司全部进行一次从小到大排名，剔除掉EV/EBITDA小于0的公司（盈利为负的公司当然应该剔除）以后，选择排名最靠前的30个公司持有，就是Alpha选股交易策略。"
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:44
msgid "其实，类似于这样的指标排序选股策略，`qteasy`提供了一个内置交易策略可以直接实现："
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:91
msgid "不过这个内置交易策略仅支持以`qteasy`内置历史数据类型为选股因子，例如pe市盈率、profit利润等数据是`qteasy`的内置历史数据，可以直接引用。但如果是``qteasy``内置历史数据中找不到的选股因子，就不能直接使用内置交易策略了。EV/EBITDA这个指标是一个计算指标，因此，我们必须使用自定义交易策略。并在自定义策略中计算该指标。"
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:92
msgid "计算选股指标"
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:94
msgid "为了计算EV/EBITDA，我们必须至少先确认`qteasy`中是否已经提供了EV和EBITDA这两种历史数据："
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:96
msgid "我们可以使用`find_history_data()`来查看历史数据是否被`qteasy`支持"
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:119
msgid "从上面的返回值可以看出，在`qteasy`的内置历史数据类型中，EBITDA是一个标准的历史数据类型，可以通过'ebitda‘ / income_ebitda 这两个ID来获取（我们将使用'ebitda'），但是EV企业现金价值并不在内置数据类型中，但我们知道EV可以通过下面的公式计算："
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:121
msgid "$$ EV = 总市值 + 总负债 - 总现金 $$"
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:123
msgid "而上面几个财务指标都是`qteasy`直接支持的："
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:125
msgid "总市值 - 数据类型： `total_mv`"
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:126
msgid "总负债 - 数据类型： `total_liab`"
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:127
msgid "总现金 - 数据类型： `c_cash_equ_end_period`"
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:129
msgid "我们可以测试一下："
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:144
msgid "可以看到选股因子已经计算出来了，那么我们可以开始定义交易策略了。"
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:145
msgid "用`FactorSorter`定义Alpha选股策略"
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:147
msgid "针对这种定时选股类型的交易策略，`qteasy`提供了`FactorSorter`交易策略类，顾名思义，这个交易策略基类允许用户在策略的实现方法中计算一组选股因子，这样策略就可以自动将所有的股票按照选股因子的值排序，并选出排名靠前的股票。至于排序方法、筛选规则、股票持仓权重等都可以通过策略参数设置。"
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:149
msgid "如果符合上面定义的交易策略，使用`FactorSorter`策略基类将会非常方便。"
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:151
msgid "下面我们就来一步步定义看看，首先继承`FactorSorter`并定义一个类，在上一个章节中，我们在自定义策略的`__init__()`方法中定义名称、描述以及默认参数等信息，然而我们也可以忽略`__init__()`方法，仅仅在创建策略对象时传入参数等信息，这也是可以的，我们在这里就这样做："
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:160
msgid "与上一节相同，在`realize()`中需要做的第一步是获取历史数据。我们知道历史数据包括`total_mv, total_liab, c_cash_equ_end_period, ebitda`等四种，这些历史数据同样是打包后存储在历史数据属性h中的。与上一章节不同的是，h是一个三维`ndarray`，形状（`shape`）为(L, M, N)，包含L层，M行、N列，分别代表每个股票、每个日期以及每种数据类型。"
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:162
msgid "因此，要获取四种数据类型最后一个周期的所有股票的数据，应该使用如下方法切片："
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:175
msgid "这样我们获取到的每一种数据类型都是一个一维数组，这个数组的长度与我们传入的备选股票池中的股票数量相同，每一个元素代表该股票的数据。加入我们的投资股票池中有三支股票，那么total_mv中就会有三个数字，分别代表三支股票的总市值，以此类推。"
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:177
msgid "做好上述准备后，计算选股因子就非常方便了，而且，由于我们使用了`FactorSorter`策略基类，计算好选股因子后，直接返回选股因子就可以了，`qteasy`会处理剩下的选股操作："
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:189
msgid "至此，仅仅用六行代码，一个自定义Alpha选股交易策略就定义好了。是不是非常简单？"
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:191
msgid "好了，我们来看看回测的结果如何？"
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:193
msgid "交易策略的回测结果"
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:195
msgid "由于我们忽略了策略类的`__init__()`方法，因此在实例化策略对象时，必须输入完整的策略参数："
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:213
msgid "然后创建一个`Operator`对象，因为我们希望控制持仓比例，因此最好使用“PT”信号类型："
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:224
#: ../../tutorials/6-more-self-defined-strategies.md:375
msgid "回测结果如下："
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:289
msgid "![在这里插入图片描述](../examples/img/output_5_1_2.png)"
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:292
msgid "回测结果显示这个策略并不能非常有效地跑赢沪深300指数，不过总体来说回撤较小一些，风险较低，是一个不错的保底策略。"
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:294
msgid "但策略的表现并不是我们讨论的重点，下面我们再来看一看，如果不用`FactorSorter`基类，如何定义同样的Alpha选股策略。"
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:295
msgid "用`GeneralStg`定义一个Alpha选股策略"
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:296
msgid "前面已经提过了两种策略基类："
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:298
msgid "**`RuleIterator`**： 用户只需要针对一支股票定义选股规则，`qteasy`便能将同样的规则应用到股票池中所有的恶股票上，而且还能针对不同股票设置不同的可调参数"
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:299
msgid "**`FactorSorter`**：用户只需要定义一个选股因子，`qteasy`便能根据选股因子自动排序后选择最优的股票持有，并卖掉不够格的股票。"
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:301
msgid "而`GeneralStg`是`qteasy`提供的一个最基本的策略基类，它没有提供任何“语法糖”功能，帮助用户降低编码工作量，但是正是因为没有语法糖，它才是一个真正的“万能”策略类，可以用来更加自由地创建交易策略。"
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:303
msgid "上面的Alpha选股交易策略可以很容易用`FactorSorter`实现，但为了了解`GeneralStg`，我们来看看如何使用它来创建相同的策略："
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:305
msgid "直接把完整的代码贴出来："
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:337
msgid "将上面的代码与`FactorSorter`的代码对比，可以发现，`GeneralStg`的代码在计算出选股因子以后，还多出了因子处理的工作："
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:339
msgid "剔除小于零的因子"
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:340
msgid "排序并选出剩余因子中最小的30个"
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:341
msgid "选出股票后将他们的持仓比例设置为3.3%"
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:343
msgid "事实上，上面的这些工作都是`FactorSorter`提供的“语法糖”，在这里我们必须手动实现而已。值得注意的是，我在上面例子中使用的排序等代码都是从`FactorSorter`中直接提取出来的高度优化的`numpy`代码，它们的运行速度是很快的，比一般用户能写出的代码快很多，因此，只要条件允许，用户都应该尽量利用这些语法糖，只有在不得已的情况下才自己编写排序代码。"
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:345
msgid "大家可以研究一下上面的代码，但是请注意，如果使用`GeneralStg`策略类，策略的输出应该是股票的目标仓位，而不是选股因子。"
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:347
msgid "下面看看回测结果："
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:349
msgid "回测结果："
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:351
msgid "使用同样的数据进行回测："
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:440
msgid "![在这里插入图片描述](../examples/img/output_7_1.png)"
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:442
msgid "两种交易策略的输出结果基本相同"
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:445
msgid "通过本节的学习，我们了解了`qteasy`提供的另外两种交易策略基类`FactorSorter`和`GeneralStg`的使用方法，实际创建了两个交易策略，虽然使用不同的基类，但是创建出了基本相同的Alpha选股交易策略。"
msgstr ""

#: ../../tutorials/6-more-self-defined-strategies.md:447
msgid "在下一个章节中，我们仍然将继续介绍自定义交易策略，但是会用一个更加复杂的例子来演示自定义交易策略的使用方法。敬请期待！"
msgstr ""

#: ../../tutorials/7-more-complicated-self-define-srtategy.md:1
msgid "使用交易策略类，创建更复杂的自定义策略"
msgstr ""

#: ../../tutorials/7-more-complicated-self-define-srtategy.md:3
msgid "`qteasy`是一个完全本地化部署和运行的量化交易分析工具包，[Github地址在这里](https://github.com/shepherdpp/qteasy)，并且可以[通过pip安装](https://blog.csdn.net/Shepherdppz/article/details/136075222?spm=1001.2014.3001.5501)："
msgstr ""

#: ../../tutorials/7-more-complicated-self-define-srtategy.md:9
msgid "`qteasy`具备以下功能："
msgstr ""

#: ../../tutorials/7-more-complicated-self-define-srtategy.md:28
msgid "**了解如何自定义交易策略**——[QTEASY教程5](5-first-self-defined-strategy.md)[QTEASY教程6](6-more-self-defined-strategies.md)"
msgstr ""

#: ../../tutorials/7-more-complicated-self-define-srtategy.md:39
msgid "在本节中，我们将介绍`qteasy`的交易策略基类，通过一个具体的例子详细讲解如何基于这几个基类，创建一个只属于您自己的交易策略。为了说明"
msgstr ""

#: ../../tutorials/7-more-complicated-self-define-srtategy.md:41
msgid "继承Strategy类，创建一个复杂的多因子选股策略"
msgstr ""

#: ../../tutorials/7-more-complicated-self-define-srtategy.md:44
msgid "在这个例子中，我们使用"
msgstr ""

#: ../../tutorials/7-more-complicated-self-define-srtategy.md:154
msgid "策略和回测参数配置，并开始回测"
msgstr ""

#: ../../tutorials/7-more-complicated-self-define-srtategy.md:155
msgid "定义好上面的策略之后，就可以开始进行回测了，我们需要在`qteasy`中创建一个交易员对象，操作前面创建的策略："
msgstr ""

#: ../../tutorials/7-more-complicated-self-define-srtategy.md:177
msgid "运行结果如下："
msgstr ""

#: ../../tutorials/7-more-complicated-self-define-srtategy.md:244
msgid "![png](img/output_4_4.png)"
msgstr ""

#: ../../tutorials/7-more-complicated-self-define-srtategy.md:248
msgid "在本节中，我们通过一个具体的例子，详细讲解了如何基于`qteasy`的交易策略基类，创建一个只属于您自己的交易策略。通过这个例子，您可以看到，`qteasy`的交易策略基类提供了足够的灵活性，可以实现您所设想的任何类型的交易策略。"
msgstr ""

#: ../../tutorials/7-more-complicated-self-define-srtategy.md:250
msgid "从下一个教程开始，我们将会介绍`qteasy`交易策略优化方法，通过多种优化算法，找到最优的交易策略参数，以及评价交易策略的性能。"
msgstr ""

#: ../../tutorials/Tutorial 06 - 交易策略的优化.md:1
msgid "交易策略的优化"
msgstr ""

#: ../../tutorials/Tutorial 06 - 交易策略的优化.md:3
#: ../../tutorials/Tutorial 07 - 交易策略的部署及运行.md:3
#: ../../tutorials/Tutorial 08 - 历史数据的操作和分析.md:3
msgid "TO BE COMPLETED"
msgstr ""

#: ../../tutorials/Tutorial 07 - 交易策略的部署及运行.md:1
msgid "交易策略的部署运行"
msgstr ""

#: ../../tutorials/Tutorial 08 - 历史数据的操作和分析.md:1
msgid "历史数据的操作和分析"
msgstr ""
